<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemalocation="http://www.w3.org/MarkUp/SCHEMA/xhtml11.xsd"
      xml:lang="en">
  <head>
    <meta http-equiv="Content-Type"
	  content="application/xhtml+xml; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=11" />

    <title>IAR Embedded Workbench Release History</title>
    <link type="text/css" rel="stylesheet" media="all"
	  href="style/ewic.css" />
  </head>
  <body>
    <div id="titlebanner">
      <div>
        <h1>Release History</h1>
      </div>
    </div>
    <div class="breadcrumb">
      <a href="index.ENU.html">IAR Information Center for Arm</a> | 
      <a href="release_notes.ENU.html">Release notes</a> | 
      <a href="components.ENU.html">Components</a> | 
      <a href="iccarm.ENU.html">Release notes for the IAR C/C++ Compiler for Arm</a> | 
      Release History
    </div>
    <div class="mainblock">
      <h2>
        Release History
      </h2>
    <!-- $Id: release_history.ENU.html 170795 2021-01-28 13:52:25Z robertma $ -->
    <ul>
      <li>
        <A HREF="#his850">V8.50</A> 2020-02-17
      </li>
      <li>
        <A HREF="#his842">V8.42</A> 2019-12-12
      </li>
      <li>
        <A HREF="#his840">V8.40</A> 2019-05-24
      </li>
      <li>
        <A HREF="#his832">V8.32</A> 2018-10-12
      </li>
      <li>
        <A HREF="#his830">V8.30</A> 2018-06-15
      </li>
      <li>
        <A HREF="#his822">V8.22</A> 2018-01-22
      </li>
      <li>
        <A HREF="#his820">V8.20</A> 2017-10-16
      </li>
      <li>
        <A HREF="#his811">V8.11</A> 2017-04-11
      </li>
      <li>
        <A HREF="#his810">V8.10</A> 2017-03-10
      </li>
      <li>
        <A HREF="#his780">V7.80</A> 2016-10-17
      </li>
      <li>
        <A HREF="#his770">V7.70</A> 2016-06-17
      </li>
      <li>
        <A HREF="#his760">V7.60</A> 2016-03-31
      </li>   
      <li>
        <A HREF="#his750">V7.50</A> 2015-11-10
      </li>   
      <li>
        <A HREF="#his740">V7.40</A> 2015-02-19
      </li>   
      <li>
        <A HREF="#his730">V7.30</A> 2014-09-24
      </li>   
      <li>
        <A HREF="#his720">V7.20</A> 2014-05-19
      </li>   
      <li>
        <A HREF="#his710">V7.10</A> 2014-02-21
      </li>   
      <li>
        <A HREF="#his670">V6.70</A> 2013-10-29
      </li>   
      <li>
        <A HREF="#his660">V6.60</A> 2013-06-27
      </li>   
      <li>
        <A HREF="#his650">V6.50</A> 2012-11-10
      </li>   
      <li>
        <A HREF="#his640">V6.40</A> 2012-06-05
      </li>   
      <li>
        <A HREF="#his630">V6.30</A> 2011-10-22 
      </li>   
      <li>
        <A HREF="#his621">V6.21</A> 2011-07-05 
      </li>   
      <li>
        <A HREF="#his620">V6.20</A> 2011-04-29 
      </li>   
      <li>
        <A HREF="#his610">V6.10</A> 2010-11-04 
      </li>   
      <li>
        <A HREF="#his550">V5.50</A> 2010-04-21   
      </li>   
      <li>
        <A HREF="#his541">V5.41</A> 2009-12-14   
      </li>   
      <li>
        <A HREF="#his540">V5.40</A> 2009-07-10   
      </li>   
      <li>
        <A HREF="#his530">V5.30</A> 2009-01-23   
      </li>   
      <li>
        <A HREF="#his520">V5.20</A> 2008-06-24   
      </li>   
      <li>
        <A HREF="#his511">V5.11</A> 2007-12-11   
      </li>   
      <li>
        <A HREF="#his510">V5.10</A> 2007-06-12   
      </li>   
      <li>
        <a HREF="#his441A">V4.41A</a> 2006-12-08
      </li>
      <li>
        <a HREF="#his440A">V4.40A</a> 2006-06-03
      </li>  
      <li>
        <a HREF="#his431A">V4.31A</a> 2006-02-03
      </li>
      <li>
        <a HREF="#his430A">V4.30A</a> 2005-06-23
      </li>
      <li>
        <a HREF="#his420A">V4.20A</a> 2005-01-10
      </li>
      <li>
        <a HREF="#his411A">V4.11A</a> 2004-06-10
      </li>
      <li>
        <a HREF="#his410B">V4.10B</a> 2004-03-09
      </li>
      <li>
        <a HREF="#his410A">V4.10A</a> 2004-02-21
      </li>
      <li>
        <a HREF="#his340C">V3.40C</a> 2003-12-12
      </li>
      <li>
        <a HREF="#his340B">V3.40B-P1</a> 2004-10-06
      </li>
      <li>
        <a HREF="#his340A">V3.40A</a> 2003-07-03
      </li>
      <li>
        <a HREF="#his330B">V3.30B</a> 2003-03-18
      </li>
      <li>
        <a HREF="#his330A">V3.30A</a> 2003-02-18
      </li>
      <li>
        <a HREF="#his321A">V3.21A</a> 2002-09-27
      </li>
      <li>
        <a HREF="#his320A">V3.20A</a> 2002-06-18
      </li>
      <li>
        <a HREF="#his311A">V3.11A</a> 2001-12-04
      </li>
      <li>
        <a HREF="#his310A">V3.10A</a> 2001-10-02
      </li>
      <li>
        <a HREF="#his210D">V2.10D</a> 2001-06-27
      </li>
      <li>
        <a HREF="#his210A">V2.10A</a> 2001-02-21
      </li>
      <li>
        <a HREF="#his130C">V1.30C</a> 2000-10-14
      </li>
      <li>
        <a HREF="#his130A">V1.30A/B</a> 2000-09-28
      </li>
      <li>
        <a HREF="#his120A">V1.20A</a> 2000-05-28
      </li>
      <li>
        <a HREF="#his110A">V1.10A</a> 2000-01-14
      </li>
    </ul>
    <p></p>

    <!-- ============================================== -->

  <h4><A NAME="his850">V8.50 2020-02-17</A></h4>
  <b>Program corrections</b>
 
<ul>
     <li>
        <p>
        In EWARM 8.50.9<br/>
        <b>[<a name='EWARM-8150'>EWARM-8150</a>, <a name='TPB-3453'>TPB-3453</a>]</b>
        When the C++17 feature <em>constexpr if</em> is used in a C++ constructor or destructor, the
        compiler can terminate with an internal error:
        <p><tt>["Front end]: assertion failed at: "...\lower_init.c", line 18985</tt>"</p>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.9<br/>
        <b>[<a name='EWARM-8118'>EWARM-8118</a>, <a name='TPB-3448'>TPB-3448</a>]</b>
        <p>The compiler can exit with an internal error when compiling code where a volatile pointer is used
        to access a field in a non-volatile struct.</p>
        <div><div>
        <pre>
        struct A
        {
          <span>int</span> x;
          <span>int</span> y;
        };
        <span>volatile</span> <span>int</span> t;
        <span>volatile</span> <span>int</span> a_x, a_y;
        <span>int</span> main(void)
        {
          struct A a = { 1, 2 };
          <span>volatile</span> <span>int</span> *vp = &amp;a.y;
          t = (*vp);
          a_x = a.y;
          a_y = a.y;
          <span>return</span> 0;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.9<br/>
        <b>[<a name='EWARM-8086'>EWARM-8086</a>, <a name='TPB-3442'>TPB-3442</a>]</b>
        <p>On optimization level High, the compiler can generate incorrect code when a pointer-type field in
        a struct is dereferenced, incremented, and then updated using the value of the original dereference
        as in the example below. The problem can also trigger if this pattern occurs after inlining.</p>
        <div><div>
        <pre>
        struct A
        {
          unsigned <span>char</span> *x;
          unsigned <span>char</span> *y;
        };
        <span>int</span> g4( struct A *ptr )
        {
          unsigned <span>char</span> len = *ptr-&gt;y++;
          ptr-&gt;y = ptr-&gt;y + len;
          <span>return</span> 0;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.9<br/>
        <b>[<a name='EWARM-8085'>EWARM-8085</a>]</b>
        <p>At medium optimization or higher, an unaligned load of a volatile member can be optimized away as
        if the access was not volatile. This can happen if the optimization is correct for a non-volatile
        member, which is the case if the load is preceded by a store of a known value to the same
        address.</p>
        <p>Example:</p>
        <pre>#pragma pack(1)
        typedef struct { volatile unsigned int x; } T;
        void f(T * p) 
		{
          p-&gt;x = 5;
          while ((p-&gt;x &amp; 16) == 0);
        }
        </pre>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.8<br/>
        <b>[<a name='EWARM-8074'>EWARM-8074</a>, <a name='TPB-3438'>TPB-3438</a>]</b>
        A regression in the compiler causes missed optimization opportunities and can lead to slower code,
        increased code size, and larger stack usage.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.9<br/>
        <b>[<a name='EWARM-8025'>EWARM-8025</a>]</b>
        Reading a two-byte struct to be either passed as a register parameter, or as a return value in
        register, can lead to reading four bytes. The extra two bytes are not used, but if the location
        where the struct is loaded from is at a protection boundary, an MPU may generate a fault.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.9<br/>
        <b>[<a name='EWARM-8011'>EWARM-8011</a>]</b>
        At high optimization levels, a call to intrinsic functions <tt>__MRRC</tt> or <tt>__MRRC2</tt> will
        lead to a compiler internal error.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.8<br/>
        <b>[<a name='EWARM-7937'>EWARM-7937</a>]</b>
        <p><b>Summary</b><br>
        The compiler performs an incorrect boundary check in the <tt>float</tt> division function for T16
        and T32 code. Results that are close to <tt>Inf</tt> (infinite) erroneously become <tt>Inf</tt> when
        the exponent of the result is one below <tt>Inf</tt>. In other words, when the result of a division
        exceeds <tt>|1.701411835e + 038|</tt> (bit pattern <tt>0x7F000000</tt> or <tt>0xFF000000</tt>), it
        becomes a <tt>signed Inf</tt>.</p>
        <p><b>Details</b><br>
        The boundary of the exponent of the result is set to <tt>0xFE</tt> instead of <tt>0xFF</tt>, which
        makes near <tt>Inf</tt> results <tt>Inf</tt> instead. The boundary check values <tt>0xFE</tt> and
        <tt>0xFF</tt> depend on which method that is used for calculating and packing the final result. In
        an earlier change to the <tt>float</tt> division optimization, the optimizer switched to a method
        where the most significant bit in the result mantissa is omitted, as a more optimal approach. The
        calculation of the exponent then also changed because it did not need to be adjusted for a set
        <tt>msb</tt> in the result mantissa, but the value in the boundary check for overflowed results
        (Inf) was not adjusted accordingly. To understand this in detail, inspect the code of the division
        function for <tt>float</tt> (T32 in this case):</p>
        <pre>dXn:  bit 0   = Guard bit
        bit 1-7 = The lowest 7 bits of the result mantissa (before rounding)
        dAux: bit  0-6  = 0
        bit  7-22 = bit 7-22 of the result (before rounding)
        bit 23-30 = 0
        bit 31    = Sign of the result
        dExp: bit 0-7 = The result exponent (before rounding)
        &lt;XX&gt;: Was 0xFE before the bug fix and 0xFF after.
        CMP     dExp,#&lt;XX&gt;              ; Check if it is overflow.
        BGE     OvFlw                   ; =&gt; Generate overflow.
        ORRS    dXn,dAux,dXn,LSR #1     ; Collect the result and set carry flag.
        ADC     dXn,dXn,dExp,LSL #23    ; Round and pack with exponent
        BX      lr
        Final result in dXn (r0):
        bit  0-22 = The mantissa (without the implicit msb bit)
        bit 23-30 = The exponent
        bit 31    = The sign bit
        </pre>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7941'>EWARM-7941</a>, <a name='TPB-3420'>TPB-3420</a>]</b>
        The compiler can terminate with an internal error ("assertion failed at: "overload.c", line xxxx in
        function_template_call_argument_deduction") in some cases that involve instantiating a class
        template without using brackets (a C++17 feature).<br>
        Example:
        <div><div>
        <pre>
        template&lt;unsigned MAX = 10&gt;
        struct XXX
        {
          XXX() : mmm(MAX) { }
          unsigned mmm;
        };
        <span>int</span> main()
        {
          XXX xxx; <span>// NOTE: Not using brackets
          </span>  <span>return</span> xxx.mmm;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7882'>EWARM-7882</a>]</b>
        In Armv8-M a function with the attribute <tt>__cmse_nonsecure_entry</tt> clears registers before
        returning, in order to not leak information from secure mode to non-secure mode. If such a function
        is compiled for FPU and has the return type <tt>float</tt>, the result register <tt>S0</tt> is also
        cleared, which means the return value does not reach the caller.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.6<br/>
        <b>[<a name='EWARM-7859'>EWARM-7859</a>, <a name='TPB-3399'>TPB-3399</a>]</b>
        <tt>If #pragma weak</tt> is placed before a declaration and there is a definition of the same
        function/variable later, the compiler incorrectly does not make the definition a weak definition.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7836'>EWARM-7836</a>, <a name='TPB-3395'>TPB-3395</a>]</b>
        <p>On optimization level <b>High</b>, the compiler can generate incorrect code when there is an
        assignment to a dereferenced pointer followed by two or more loops in sequence, where the first loop
        reads an array or dereferences a pointer of the same type or of type <tt>char*</tt> and the second
        loop modifies the assigned pointer. A triggering example is shown below.</p>
        <p>In this example, the bug triggers when the <tt>Byte</tt> type is either <tt>char</tt> or
        <tt>uint16_t</tt>. The observed effect, in this case, is that the assignment <tt>*value=0</tt> is
        not performed.</p>
        <div><div>
        <pre>
        bool cvt16(<span>const</span> <span>Byte</span> bytes[], <span>int</span> size, uint16_t *value)
        {
          bool result = <span>true</span>;
          *value = 0U;
          int16_t tCnt = (int16_t)size - sizeof(uint16_t);
          int16_t a = 0;
          <span>while</span> (a &lt; tCnt)
          {
            <span>if</span> (0U != bytes[a])
            {
              result = <span>false</span>;
            }
            a++;
          }
          <span>while</span> (a &lt; size)
          {
            (*value) &lt;&lt;= 8;
            (*value) |= bytes[a];
            a++;
          }
          <span>return</span> result;
        }
        </code></pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7762'>EWARM-7762</a>, <a name='TPB-3371'>TPB-3371</a>]</b>
        <tt>std::unique_ptr&lt;T&gt;</tt>, where <tt>T</tt> is an array type, is missing a default argument for 
        the <tt>nullptr_t</tt> overload of the <tt>reset</tt> member function:<br>
        <div><div>
        <pre>
        reset(nullptr_t = nullptr);
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7752'>EWARM-7752</a>, <a name='TPB-3370'>TPB-3370</a>]</b>
        If a preinclude file is specified, the compiler uses its name as the name of the module, instead of
        using the name of the main source file. This mainly affects code coverage.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.4<br/>
        <b>[<a name='EWARM-7735'>EWARM-7735</a>, <a name='TPB-3365'>TPB-3365</a>]</b>
        If the declaration of a function uses the <tt>__weak</tt> keyword and the definition does not, the
        function is incorrectly generated as a weak symbol.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.4<br/>
        <b>[<a name='EWARM-7713'>EWARM-7713</a>, <a name='TPB-3363'>TPB-3363</a>]</b>
        The compiler can terminate with an internal error ('[Front end]: assertion failed at:
        "lower_name.c", line 2542 in mangled_encoding_for_function_type') in some cases that involve the use
        of a lambda function in certain scopes (like the condition scope in an if statement).
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7688'>EWARM-7688</a>, <a name='TPB-3358'>TPB-3358</a>]</b>
        A floating-point expression that is cast to an integer type <em>N</em>, where one operand is a
        floating-point constant with a value that is exactly representable as an integer, and the other
        operand is an integer expression with type <em>T</em>, is evaluated in <em>T</em>, rather than the
        type <em>N</em>. For example, the expression <tt>(uint32_t)((uint16_t)a*32768.0)</tt> is evaluated
        in <tt>uint16_t</tt> rather than <tt>uint32_t</tt>, possibly leading to unexpected results.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7540'>EWARM-7540</a>, <a name='TPB-3325'>TPB-3325</a>]</b>
        On optimization level High, the compiler can incorrectly move pointer-based loads and stores across
        the definition of the pointer variable. This problem can occur when a pointer is repeatedly
        de-referenced inside a loop, and the pointer variable is defined or first set inside the same loop.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.4<br/>
        <b>[<a name='EWARM-7531'>EWARM-7531</a>, <a name='TPB-3324'>TPB-3324</a>]</b>
        The compiler can fail to compile some C++ source code that involves <tt>constexpr</tt> array access
        with a non-zero index, erroneously emitting error Pe028: "expression must have a constant value",
        adding "[note]: attempt to access storage one position past an object treated as an array of one
        element".
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7460'>EWARM-7460</a>]</b>
        <p>Internal error when compiling a function with attribute <tt>__naked</tt> that ends with an inline
        <tt>asm</tt> statement that contains a literal pool load, if there is another function in the
        module. For example:</p>
        <div><div>
        <pre>
        __naked <span>int</span>* f(void) { __asm <span>volatile</span>(<span>"LDR R0, =x"</span>); }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.50.7<br/>
        <b>[<a name='EWARM-7440'>EWARM-7440</a>, <a name='TPB-3309'>TPB-3309</a>]</b>
        On optimization level High, the compiler can generate incorrect code for functions that write to
        variables with static storage duration and have a loop nesting that is not strictly hierarchical
        (that is, when two loops intersect and neither is completely inside the other).
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7421'>EWARM-7421</a>, <a name='TPB-3295'>TPB-3295</a>]</b>
        Compilation can fail if a structure field has the same name as a type.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7365'>EWARM-7365</a>, <a name='TPB-3306'>TPB-3306</a>]</b>
        When compiling for Armv8-M with the <tt>--cmse</tt> (secure mode) option set, a call to a function
        with the attribute <tt>__cmse_nonsecure_entry</tt> will unexpectedly return in non-secure mode.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7358'>EWARM-7358</a>, <a name='TPB-3279'>TPB-3279</a>]</b>
        The compiler can terminate with an internal error ("[Front end]: assertion failed at:
        "lower_init.c", line 3396 in add_constructor_call") in some cases that involve C++ multiple
        inheritance.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7357'>EWARM-7357</a>, <a name='TPB-3278'>TPB-3278</a>]</b>
        In some cases, the compiler does not properly take using declarations into consideration for
        conversion functions and erroneously emits an error. <br>
        Example:
        <div><div>
        <pre>
         struct X { <span>operator</span> bool() <span>const</span>; };
         struct Y { <span>operator</span> bool() <span>const</span>; };
         struct D: X, Y {
           using X::<span>operator</span> bool;
         };
         bool foo(D d) {
           <span>return</span> d;  <span>// Incorrectly reported as ambiguous</span>
         }</pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7312'>EWARM-7312</a>, <a name='TPB-3271'>TPB-3271</a>]</b>
        The compiler can terminate with an internal error when code contains a constant that consists of
        a <tt>__section_begin</tt> or <tt>__section_end</tt> operator with an offset, converted to a
        function pointer. <br>
        Example:
        <div><div>
        <pre>
        #pragma section = <span>"SEC"</span>
        typedef void (*fun_t)(void);
        void
        foo(void)
        {
          fun_t fp = (fun_t)((<span>long</span>)__section_begin(<span>"SEC"</span>) + 1);
          fp();
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7306'>EWARM-7306</a>]</b>
        When compiling for baseline profile M devices (Cortex-M0/M0+/M1/M23), a function definition with the
        attribute <tt>__svc</tt> that contains a function call which is not inlined, results in an internal
        error.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7270'>EWARM-7270</a>, <a name='TPB-3262'>TPB-3262</a>]</b>
        Mistakenly, the compiler never does emit warning Pa149 ("some enum values are not handled in this
        switch statement..."). This warning is for switch statements on an enum type, where there is no
        default case, all cases are for enum constants of the given type, and some enum constants are not
        handled.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7264'>EWARM-7264</a>, <a name='TPB-3261'>TPB-3261</a>]</b>
        The compiler can terminate with an internal error ("assertion failed: lower_constant: bad kind") in
        some cases that involve braced initialization of a multi-level aggregate class
        like <tt>std::array</tt> with a dynamic value more than one level down, when exceptions are
        disabled.<br>
        Example:
        <div><div>
        <pre>
        #include &lt;array&gt;
        struct tValues
        {
          <span>int</span> val;
        };
        
        <span>int</span> fun();
        std::array&lt;tValues, 1&gt; arr{{ { fun() } }};
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6955'>EWARM-6955</a>, <a name='TPB-3196'>TPB-3196</a>]</b>
        The compiler sometimes fails to update the debug information for variables whose storage location
        changed by being moved from one processor register into another processor register.
        </p>
     </li>
</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>
 
 
  <h4><A NAME="his842">V8.42 2019-12-12</A></h4>
  <b>Program corrections</b>
 
<ul>
     <li>
        <p>
        <b>[<a name='EWARM-7148'>EWARM-7148</a>, <a name='TPB-3244'>TPB-3244</a>]</b>
        <p>The compiler can terminate with an internal error in some cases that involve the initialization
        of a block-local anonymous union. Example:</p>
        <div><div>
        <pre>
        <span>int</span> val;
        void foo(void)
        {
          union
          {
            <span>int</span> x;
            <span>char</span> y;
          } = { val };
        };</pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7146'>EWARM-7146</a>, <a name='TPB-3243'>TPB-3243</a>]</b>
        The C++ library class <tt>std::ratio</tt> cannot be used in <tt>constexpr</tt> expressions.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7143'>EWARM-7143</a>, <a name='TPB-3241'>TPB-3241</a>]</b>
        The compiler will terminate with an internal error if a static class constructor is initialized with
        a constant array element with a known value that has an aggregate type.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7085'>EWARM-7085</a>, <a name='TPB-3226'>TPB-3226</a>]</b>
        In some cases, the compiler generates a call to <tt>memset</tt> to zero-initialize a variable or
        part of a variable. Normally, at higher optimization levels, this call is inlined or otherwise
        optimized. When the target variable is volatile, the call is not inlined or otherwise optimized.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7056'>EWARM-7056</a>, <a name='TPB-3220'>TPB-3220</a>]</b>
        The compiler can terminate with an "out of memory" error in some cases that typically involve many
        constant address expressions for addresses in large objects.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7030'>EWARM-7030</a>, <a name='TPB-3210'>TPB-3210</a>]</b>
        <p>On optimization level High, the compiler can exit with a null pointer exception in some cases.
        This occurs when compiling code where a pointer is used to loop backward over a buffer, and the
        start and stop values are expressed as addresses of buffer elements with constant index. See this
        example:</p>
        <div><div>
        <pre>
        <span>char</span> b[5];
        <span>char</span> *c, *d;
        <span>int</span> e(void) {
          c = &amp;b[1];
          d = &amp;b[5];
          <span>while</span> (d &gt;= c)
            d--;
          <span>return</span> 0;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7017'>EWARM-7017</a>, <a name='TPB-3206'>TPB-3206</a>]</b>
        <p>Compiling code that initializes a variable with the address of an array type member variable of
        an object, can cause an internal error. For example, (C++, but this can happen in similar cases in C
        as well):</p>
        <div><div>
        <pre>
        struct A { <span>int</span> x; };
        struct B { A a[1][1]; };
        B b;
        A* x = &amp;b.a[0][0];
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6886'>EWARM-6886</a>, <a name='TPB-3176'>TPB-3176</a>]</b>
        <p>On optimization level High, the compiler can generate incorrect code for loops with a constant
        trip count and a body that contains bit operations introduced by inlining. See this example:</p>
        <div><div>
        <pre>
        <span>const</span> uint8_t aVar[64] = {  
           0,  1,  2,  3,  4,  5,  6,  7,
           8,  9, 10, 11, 12, 13, 14, 15,
          16, 17, 18, 19, 20, 21, 22, 23,
          24, 25, 26, 27, 28, 29, 30, 31 };
        <span>char</span> gData[32];
        inline void g(uint8_t x) { gData[x] = (x &amp; 0x3f); }
        #pragma inline=never
        void f(void)
        {
          <span>for</span> (<span>int</span> j = 0; j &lt; (32); j++)
          {
            g(aVar[j]);
          }
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6840'>EWARM-6840</a>, <a name='TPB-3161'>TPB-3161</a>]</b>
        <p>On optimization level High, the compiler can fail to terminate when function inlining is used
        together with the loop unrolling optimization, and the inlined function contains a loop and returns
        the value of a function call. This sample code triggers the problem:</p>
        <div><div>
        <pre>
        <span>char</span> c[2];
        <span>int</span> j(void);
        <span>int</span> h(<span>int</span> x)
        {
          <span>for</span> (<span>int</span> l = 0; l &lt; 2; l++)
          *c = x;
          <span>return</span> j();
        }
        <span>int</span> n()
        {
          <span>int</span> a = h(4);
          <span>return</span> a;
        }
        </pre>
        </div></div>
        </p>
     </li>
</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>
 
 

  <h4><A NAME="his840">V8.40 2019-05-24</A></h4>
  <b>Program corrections</b>
 
  <ul>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6992'>EWARM-6992</a>, <a name='TPB-3198'>TPB-3198</a>]</b>
        On optimization level High, the compiler can generate incorrect code for loops where the loop
        test is inside a switch statement and the loop variable is updated by post-incrementation, as in
        this example:</p>
        <div><div>
        <pre>
        <span>char</span> buf[10] = {1,2,3,4,5,6,7,8,9,10};
        <span>int</span> main(void)
        {
          <span>int</span> value = 255;
          <span>for</span> (<span>int</span> i = 0;;)
          {
            <span>switch</span>(buf[i++])
            {
            <span>default</span>:
              <span>continue</span>;
            <span>case</span> 10:
              <span>break</span>;
            <span>case</span> 1:
              value = 1;
              <span>break</span>;
            <span>case</span> 2:
              value = 2;
              <span>break</span>;
            }
            <span>break</span>;
          }
          printf(<span>"%d\n"</span>, value);
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6956'>EWARM-6956</a>, <a name='TPB-3190'>TPB-3190</a>]</b>
        For most C runtime library functions, redeclaring the function inside a C++ namespace after
        including the relevant system header will display the false error message:
        <p><tt>Error[Pe337]: linkage specification is incompatible with previous "..."</tt></p>
        </p>
     </li>
     <li>
        <p>
		In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6940'>EWARM-6940</a>, <a name='TPB-3189'>TPB-3189</a>]</b>
        The compiler can terminate with an internal error in some cases involving aggregate initialization
        of a structure containing an array of structures with one or more const data members.
        </p>
     </li>
     <li>
        <p>
		In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6939'>EWARM-6939</a>]</b>
        It is not possible to use the 2-operand variants of the <tt>SUB</tt> and
        <tt>SUBS</tt> instructions. 
        <br/><i>See also EWARM-6765</i>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6935'>EWARM-6935</a>, <a name='TPB-3188'>TPB-3188</a>]</b>
        The compiler can terminate with an internal error in some cases involving aggregate initialization
        of a class/struct/union with one or more base classes.
        </p>
     </li>
     <li>
        <p>
		In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6924'>EWARM-6924</a>, <a name='TPB-3184'>TPB-3184</a>]</b>
        When compiling C++ code, the IAR C/C++ Compiler can terminate with an internal error in some cases
        involving template class in-class data member initializers.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6921'>EWARM-6921</a>, <a name='TPB-3181'>TPB-3181</a>]</b>
        The inline functions for the generic functions <tt>isunordered</tt> and <tt>islessgreater</tt> have
        the wrong return types in C. This triggers MISRA-C:2004 rule 10.1 messages in the compiler and in
        C-STAT.
        </p>
     </li>
	 <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6912'>EWARM-6912</a>, <a name='TPB-3197'>TPB-3197</a>]</b>
        In some complicated template cases, the compiler can erroneously emit error Pe871 ("template
        instantiation resulted in unexpected function type of ... (the meaning of a name may have changed
        since the template declaration ...")
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6885'>EWARM-6885</a>, <a name='TPB-3178'>TPB-3178</a>]</b>
        The configuration setting to make all enumeration types at least the size of n int has no effect.
        Enumeration types can still get a smaller underlying type if all enumeration constants fit.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6878'>EWARM-6878</a>, <a name='TPB-3174'>TPB-3174</a>]</b>
        On optimization level Medium and above, the compiler can generate incorrect code for modules that
        contain both weak function definitions and calls to those functions.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6849'>EWARM-6849</a>, <a name='TPB-3169'>TPB-3169</a>]</b>
	    The compiler can terminate with an internal error (Internal error: [Front end]: assertion failed at:  "...\lower_il.c") in some cases that involve using the address of a member variable in an aggregate field initializer.<br>
        </p>

        Example:
        <div><div>
        <pre>
        #include <array>
        <span>struct</span> XXX
        {
          <span>int</span> mI;
          std::array<int *, 2> mA = \{ &mI, 0 };
        };
        </pre>
        </div></div>
     </li> 
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6838'>EWARM-6838</a>, <a name='TPB-3159'>TPB-3159</a>]</b>
        Code that contains very large functions with extensive use of <tt>if</tt> statements and variables
        with static storage duration can take a long time to compile.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6819'>EWARM-6819</a>, <a name='TPB-3154'>TPB-3154</a>]</b>
        The compiler can generate incorrect code for expressions of the type <tt>*(&amp;i + f()) =
        1;</tt> when <tt>i</tt> is a scalar variable with automatic storage duration. When inlining is
        enabled, that is, on optimization level High, this problem is triggered also by the example
        below.</p>
        <div><div>
        <pre>
        <span>static</span> void change(<span>int</span> *x, <span>int</span> val)
        {
          x += f();
          *x = val;
        }
        void params(<span>int</span> i, <span>int</span> j)
        {
          change(&amp;i, 1);
          change(&amp;j, 2);
          printf(<span>"i=%d,j=%d\n"</span>, i, j);
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6808'>EWARM-6808</a>]</b>
        The signature for the function <tt>cmse_check_address_range</tt> in the header file
        <tt>arm_acle.h</tt> has been updated to use <tt>void*</tt> instead of <tt>void const*</tt> for the
        pointer type, as specified by "ARMv8-M Security Extensions: Requirements on Development Tools"
        (ARM-ECM-0359818).
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6754'>EWARM-6754</a>, <a name='TPB-3115'>TPB-3115</a>]</b>
        Using the gnu-style attribute <tt>noreturn</tt> on a typedef of a function pointer, causes the
        compiler to terminate with an internal error. Example:</p>
        <pre>   typedef void (*foo)() __attribute__((noreturn));
        </pre>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.40.2:<br>
        <b>[<a name='EWARM-6744'>EWARM-6744</a>]</b>
        When a non-ramfunc function is inlined into a __ramfunc function, warning Ta023 "Call to a non
        __ramfunc function from within a __ramfunc function" is issued. This is incorrect; after the call is
        inlined there is no call, and the inlined code is inside the caller, which is a __ramfunc function.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6825'>EWARM-6825</a>]</b>
        The speed-optimized implementation of <tt>memcmp</tt> for Cortex-M0, M0+, and M23 can trigger a
        HardFault on the target system when the pointer parameters are not co-aligned <tt>modulo 4</tt>, in
        other words when the last two bits of the pointers have different values.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6768'>EWARM-6768</a>, <a name='TPB-3127'>TPB-3127</a>]</b>
        The compiler can exit with an internal error when compiling C++ code that contains initialization
        expressions with C99-style named designators. Note that named designators are not allowed by the C++
        14 standard.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6753'>EWARM-6753</a>]</b>
        The compiler can exit with an internal error when compiling code with an if statement that
        contains a call to one of the intrinsic functions <tt>__iar_builtin_VRINTA_F64,
        __iar_builtin_VRINTM_F64, __iar_builtin_VRINTN_F64, __iar_builtin_VRINTP_F64, __iar_builtin_VRINTA_F32,
        __iar_builtin_VRINTM_F32, __iar_builtin_VRINTN_F32, </tt>or <tt>__iar_builtin_VRINTP_F32.</tt></p>
        <div><div>
        <pre>
        <span>float</span> fx(<span>float</span> a, <span>int</span> rm)
        {
          <span>if</span> (rm == 1)
          {
            a = __VRINTM_F32(a);
          }
          <span>return</span> a;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6750'>EWARM-6750</a>]</b>
        If a C++ template class contains a single float, in some cases the caller and the callee do not
        agree on whether the return type is a homogeneous aggregate. When compiling with Vector Floating
        Point (VFP) support, this means that the callee can return a value in one register (S0), and the
        caller uses the value in another register (R0).
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6737'>EWARM-6737</a>, <a name='TPB-3112'>TPB-3112</a>]</b>
        On optimization level Medium and higher, the compiler can exit with an internal error when it
        processes code that contains both functions with <tt>#pragma inline=forced</tt> and functions with
        <tt>#pragma optimize=none</tt>. See this example:</p>
        <div><div>
        <pre>
        void f1(void);
        #pragma inline=forced
        void f2(<span>int</span> a)
        {
          f1();
        }
        #pragma inline=forced
        void f3(<span>int</span> a)
        {
          f2(a);
        }
        #pragma optimize=none
        <span>int</span> main(void)
        {
          <span>int</span> a = 0;
          f3(a);
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6726'>EWARM-6726</a>, <a name='TPB-3111'>TPB-3111</a>]</b>
        Using variable templates in conjunction with multi-file compilation (--mfc) can result in an
        internal error ("Internal Error: [Front end]: assertion failed: may_have_correspondence:<br>
        bad symbol kind ...").
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6719'>EWARM-6719</a>]</b>
        When loading constants that can be expressed as the bit-inversion of a rotated immediate value, the
        compiler and assembler can generate invalid ARM-mode instructions.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6716'>EWARM-6716</a>]</b>
        The compiler fails to take side effects of the <tt>LDREX</tt> instruction into account, which can
        result in the instruction being removed if the loaded data is not used.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6701'>EWARM-6701</a>, <a name='TPB-3100'>TPB-3100</a>]</b>
        The compiler can terminate with an internal error ("assertion failed at: ...\interpret.c, line
        4425") when compiling an expression that contains a section begin/end operator with an offset. For
        example:
        <p><tt>   (char*) __section_begin("MyOverlay") + 1</tt></p>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6700'>EWARM-6700</a>, <a name='TPB-3102'>TPB-3102</a>]</b>
        On optimization level Medium and above, the compiler can exit with an internal error for code
        that extracts parts of an integer, using a union that contains a struct and an integer like in the
        example below:</p>
        <div><div>
        <pre>
        struct A
        {
          <span>char</span> a;
          <span>char</span> b;
        };
        union B
        {
          struct A c;
          <span>int</span> d;
        };
        <span>int</span> f(<span>int</span> g)
        {
          <span>int</span> h;
          union B k;
          <span>for</span> (<span>int</span> i = 0; i &lt;= g; i++)
          {
            <span>if</span> (k.c.b)
            {
              h = k.d;
            }
          }
          <span>return</span> h;
        }
        }
          <span>return</span> h;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6685'>EWARM-6685</a>, <a name='TPB-3093'>TPB-3093</a>]</b>
        The compiler can exit with an internal error when compiling C++ code if it encounters type
        punning casts of constants, like in this example:</p>
        <div><div>
        <pre>
        <span>const</span> <span>int</span> a = 0x7FA00000;
        struct b
        {
          <span>float</span> c;
          b() : c(*(<span>float</span> *)&amp;a)
          {
          }
        };
        void d()
        {
          b e;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6536'>EWARM-6536</a>, <a name='TPB-3110'>TPB-3110</a>]</b>
        The compiler can terminate with an internal error when <tt>#pragma _<em>printf_args</em></tt>
        or <tt>_scanf_args</tt> is used on a C++ function that returns a temporary object that requires
        destruction.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6531'>EWARM-6531</a>, <a name='TPB-3057'>TPB-3057</a>]</b>
        The compiler can emit spurious warnings (Pa118) about mixing <tt>bool</tt> and non-boolean types in
        comparison expressions.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6335'>EWARM-6335</a>, <a name='TPB-2997'>TPB-2997</a>]</b>
        The compiler can terminate with an internal error in C++ mode in some cases involving initialization
        of an aggregate with integer members and a non-constant more than one level down.
        </p>
     </li>
  </ul>
 
 
  <b>New features</b>
 
  <ul>
    <li>
      None.
    </li>
  </ul>
 



  <h4><A NAME="his832">V8.32 2018-10-12</A></h4>
  <b>Program corrections</b>
 
<ul>
     <li>
        <p>
        In EWARM 8.32.3<br>
        <b>[<a name='EWARM-6657'>EWARM-6657</a>, <a name='TPB-3083'>TPB-3083</a>]</b>
        On optimization level High, the compiler can exit with an internal error when compiling code that
        contains loops with shifts inside.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.32.3<br>
        <b>[<a name='EWARM-6634'>EWARM-6634</a>, <a name='TPB-3081'>TPB-3081</a>]</b>
        The compiler can terminate with an internal error for code that uses the variadic template operator 
		sizeof... in a constant expression.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.32.3<br>
        <b>[<a name='EWARM-6615'>EWARM-6615</a>, <a name='TPB-3077'>TPB-3077</a>]</b>
        On optimization level High, the function inlining optimization can cause the compiler to generate
        invalid code if the C++ operator placement new is used more than once in the same function, and at
        least twice places objects at the same address. As an example, consider the code below. When this
        code is compiled, the call to the constructor for <tt>YYYYY</tt> will incorrectly be removed on
        optimization level High, if the function inlining optimization is enabled.</p>
        <div><div>
        <pre>
        void Bug::Bug()
        {
          mI = <span>new</span> (mBuffer) XXXXX();
          mI = <span>new</span> (mBuffer) YYYYY();
          <span>int</span> data = mI-&gt;V();
          <span>if</span> (data != 0)
          {
            showNr(data);
          }
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.32.2<br>
        <b>[<a name='EWARM-6594'>EWARM-6594</a>, <a name='TPB-3073'>TPB-3073</a>]</b>
        Multi-file compilation (–mfc) with C++ files where at least one file includes the &lt;new&gt; header
        and at least one file does not, incorrectly generates this error:
        <p>  Error[Pe1061]: declaration of enum "std::align_val_t" is incompatible with a declaration in
        another translation unit (...)</p>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.32.2<br>
        <b>[<a name='EWARM-6555'>EWARM-6555</a>, <a name='TPB-3064'>TPB-3064</a>]</b>
        <p>The compiler can crash when compiling code where two copies of the same 32-bit value are combined
        into one 64-bit value as shown in the example below.</p>
        <div><div>
        <pre>
        uint64_t combine(uint32_t v)
        {
          <span>return</span> ((uint64_t)v &lt;&lt; 32) | (uint64_t) v;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6518'>EWARM-6518</a>, <a name='TPB-3053'>TPB-3053</a>]</b>
        In modules where the type of an integer bitfield is specified with an explicit <tt>signed</tt>
        modifier, the compiler will sometimes produce debug information where the signed integer types used
        this way are incorrectly given names that include the <tt>signed</tt> modifier. This can lead to a
        degraded debug experience, because it can cause the debugger to fail to unify structure types
        correctly.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6454'>EWARM-6454</a>, <a name='TPB-3043'>TPB-3043</a>]</b>
        The compiler can terminate with an internal error in some cases involving an <tt>&amp;</tt> operator
        where one operand is an integer constant expression involving a non-type template parameter.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6416'>EWARM-6416</a>, <a name='TPB-3042'>TPB-3042</a>]</b>
        Compiling source code that contains an <tt>if constexpr</tt> statement with no <tt>else</tt> part,
        and a false condition causes the compiler to terminate with an internal error.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6414'>EWARM-6414</a>, <a name='TPB-3027'>TPB-3027</a>]</b>
        The warning message Pe182 ("bitwise operation drops significant bits from a constant") can be issued
        incorrectly. It exists to warn about cases like
        <pre>    if (uchar &amp; 0x400)
        </pre>
        <p>but it is sometimes issued in cases where no such problem exists.</p>
        </p>
     </li>
</ul>
 
 
  <b>New features</b>
 
<ul>
  <li><p><b>C18 support</b><br />
            The default Standard C is now C18 (ISO/IEC 9899:2018).
  </p></li>
  <li><p><b>C++17 support</b><br />
            The compiler now supports all C++17 features. The C++ library supports C++14 with no C++17 additions.
  </p></li>
 </ul>
 


  <h4><A NAME="his830">V8.30 2018-06-15</A></h4>
  <b>Program corrections</b>
 
<ul>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6480'>EWARM-6480</a>, <a name='TPB-3040'>TPB-3040</a>]</b>
        A regression causes compilation of files containing large constant integer-only arrays 
        to run out of memory.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6471'>EWARM-6471</a>, <a name='TPB-3039'>TPB-3039</a>]</b>
        <p>The compiler could issue a spurious error in some cases involving variadic member function
        templates.</p>
        <p>Example:</p>
        <pre>  
        struct A {
          struct B {
            void g() { A a; a.f(1); }
          };
          void h(int){}
          template&lt;typename... Ts&gt; void f(Ts... args) {
            h(args...);  // Spurious Pe018 (expected a ")") error here
          }
        };
        
        int main() {
          A::B B;
          B.g();
        }
        </pre>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6455'>EWARM-6455</a>, <a name='TPB-3034'>TPB-3034</a>]</b>
        The compiler incorrectly issues the Pe831 remark (support for placement delete is disabled) for the
        builtin declaration of operator delete when compiling with exceptions disabled.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6447'>EWARM-6447</a>, <a name='TPB-3032'>TPB-3032</a>]</b>
        Returning a part of a union with an offset will return the part without offset if the function is
        inlined. For example, <br>
         
        <div><div>
        <pre>
        union un
        { <span>long</span> <span>long</span> a; <span>long</span> b[2]; }
        ;
        <span>long</span> f()
        { un x; ... <span>return</span> x.b[1]; <span>// returns x.b[0] when inlined }</span>
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6440'>EWARM-6440</a>]</b>
        The template C++ library does not build for Cortex-M4 with VFP-v4.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6438'>EWARM-6438</a>]</b>
        When checking for MISRA-C:2004 rule 2.4 deviances, the compiler mistakenly triggers 
        for Shift JIS multibyte characters in comments where the second byte is ';' or '}'.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6409'>EWARM-6409</a>]</b>
        On optimization level Medium and above, the compiler can generate incorrect code for min and max
        like question mark expressions like <tt>x &lt; y ? y : x</tt>. If the type of the expression is
        smaller than <tt>int</tt> and the order of variables in the comparison is different from the order
        in the colon-part, the used value of one of the variables is not always extended properly.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.30.2<br>
        <b>[<a name='EWARM-6394'>EWARM-6394</a>]</b>
        A low-level optimization pass can in rare cases create an unpredictable <tt>STR</tt> instruction
        when the source register is the same as the base register, and write-back is used.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-7459'>EWARM-7459</a>, <a name='TPB-3314'>TPB-3314</a>]</b>
        On optimization level Medium and higher, the compiler can generate incorrect code if the common
        sub-expression elimination optimization is enabled.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6896'>EWARM-6896</a>]</b>
        On optimization level Medium and above, the compiler can in some rare cases generate incorrect 
        code when a Vector Floating Point (VFP) coprocessor or the Vectorization transformation is used. 
        The problem is not triggered by a specific construct in the source code.
        </p>
        <p>The problem can only be detected by inspecting the compiler list files. If a function pushes a 
        VFP register that is not used within the function, it is an indication that the problem might have 
        occurred and that this function needs a more detailed inspection.
        </p>
     </li>     
     <li>
        <p>
        <b>[<a name='EWARM-6532'>EWARM-6532</a>]</b>
        <p>The symbol {{__ARM_BIG_ENDIAN}} from ACLE (ARM C Language Extensions) is defined incorrectly 
        as {{0}} for little-endian projects. The symbol should not be defined for little-endian projects. 
        </p>
     </li>     
     <li>
        <p>
        <b>[<a name='EWARM-6336'>EWARM-6336</a>, <a name='TPB-2996'>TPB-2996</a>]</b>
        <p>The compiler can generate incorrect code for min and max-like qmark expressions when the
        condition compares two variables and the value of the expression is the value of either variable
        casted to a narrower type. The same bug can also trigger for <tt>if</tt> statements where the
        condition compares two variables and the <tt>then</tt> and <tt>else</tt> clause only assigns the
        value of either variable to another variable with a narrower type. </p>
        <p>An example of the first case is shown below. The triggering criteria is the qmark expression, the
        <tt>if</tt> statement is there to prevent the compiler from removing the qmark.</p>
        <div><div>
        <pre>
        <span>int</span> b;
        void e(unsigned <span>int</span> a, <span>int</span> c)
        {
          unsigned <span class="code-object">int</span> d = (a &gt; c) ? (unsigned <span
          class="code-object">short</span>)c :  (unsigned <span class="code-object">short</span>)a;
          <span class="code-keyword">if</span> (d)
          b = d;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6322'>EWARM-6322</a>]</b>
        On optimization level High, when FPU support is enabled, and the target FPU has 32 D registers, the
        compiler can generate incorrect code for loading floating-point constants that can be represented
        with a 1-bit exponent and a 6-bit mantissa.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6309'>EWARM-6309</a>, <a name='TPB-2989'>TPB-2989</a>]</b>
        On optimization level High, the code generated by the compiler can differ between invocations for
        source code where 1. the value of a local variable is conditionally set to two different constant
        values, 2. all uses of this variable are part of an identical subexpression, and 3. at least one but
        not all of these subexpressions is part of a larger bit-wise OR. This error does not affect the
        correctness of the code.
        <p>This code can trigger the issue:</p>
        <div><div>
        <pre>
        <span>int</span> f(<span>int</span> x)
        {
          <span class="code-object">int</span> a = (x == 5 ? 10 : 7);
          <span class="code-object">int</span> b = 3 * a;
          <span class="code-object">int</span> c = 7 | (3 * a);
          <span class="code-keyword">return</span> b + c;
        }
        </pre>
        </div></div>
        <p>while this code can't</p>
        <div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
        <pre class="code-java">
        <span class="code-object">int</span> f(<span class="code-object">int</span> x)
        {
          <span class="code-object">int</span> a = (x == 5 ? 10 : 7);
          <span class="code-object">int</span> b = 3 * a;
          <span class="code-object">int</span> c = 7 - (3 * a);
          <span class="code-keyword">return</span> b + c;
        }
        </pre>
        </div></div>
        <p>As a special case, the issue can be triggered by bitfield struct assignments when the address of
        the struct is conditionally set to two different constant values, if all uses of the struct address
        are part of identical subexpressions. In this case, the subexpression that contains the bit-wise OR
        is part of the bitfield assignment.</p>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6306'>EWARM-6306</a>]</b>
        Using the intrinsic function <tt>_<em>RBIT()</em></tt> or <tt>_rbit()</tt> on an architecture that
        does not support the instruction <tt>RBIT</tt> can cause an internal error on optimization level
        Medium or higher.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6279'>EWARM-6279</a>, <a name='TPB-2975'>TPB-2975</a>]</b>
        The library static variable _Isdst_rules is defined in both the 32-bit and the 64-bit code for
        time-handling. This can give an redefinition error at linkage.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6270'>EWARM-6270</a>, <a name='TPB-2973'>TPB-2973</a>]</b>
        <p>On optimization level High, the compiler can crash with an internal error or possibly generate
        incorrect code when compiling loops like the example below. The necessary conditions to trigger this
        problem are: a) The loop variable is a pointer that is stepped using pointer arithmetic. b) Inside
        the loop, the loop variable is indexed by a sum of two values that are not changed within the
        loop.</p>
        <div><div>
        <pre>
        void f(<span>int</span> *x, <span>int</span> b, <span>int</span> c, <span>int</span> d)
        {
          <span class="code-keyword">for</span> (<span class="code-object">int</span> *a = x; *a &lt; 1  ; a = a + d)
          {
            a[0] = a[c + b];
          }
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6250'>EWARM-6250</a>, <a name='TPB-2963'>TPB-2963</a>]</b>
        On optimization level None the compiler can exit with an internal error when compiling code that
        contains an anonymous union where one of the data members is a bitfield.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6240'>EWARM-6240</a>, <a name='TPB-2961'>TPB-2961</a>]</b>
        When performing MISRA C checking in C++ mode, the compiler can erroneously report a violation of
        rule 12.5 (operands of <tt>&amp;&amp;</tt> and <tt>||</tt> must be primary expressions) for the
        right-hand operand if that operand is not of <tt>bool</tt> type.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6238'>EWARM-6238</a>]</b>
        On optimization level Medium and above, and when compiling for Thumb targets, the compiler can
        generate incorrect code when the value of a Boolean variable is set to the result of a variable
        compared to a constant. Typical code that can trigger the bug is <tt>y = (x &gt; 5 ? 0 : 1)</tt>,
        but code that can be transformed into this form by the compiler can also be affected.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6219'>EWARM-6219</a>, <a name='TPB-2958'>TPB-2958</a>]</b>
        <p>The compiler can fail to compile files with C++ code that use variadic function templates with
        default template arguments.</p>
        <p>If a variadic function template has a default template argument that contains a pack expansion
        that uses an enclosing non-variadic parameter, a<br>
        substitution failure can result. This in turn will cause one of a number of errors, typically "no
        instance of ... matches the argument list".</p>
        <p>Example:</p>
        <div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
        panelContent">
        <pre>
        struct C {};
        template &lt;typename... Ts&gt; struct A;
        template&lt;typename, typename&gt; struct B {
          static constexpr bool v = false;
        };
        template&lt;bool... T&gt; struct F;
        template &lt;bool... Bs&gt; using E = B&lt; F&lt;Bs...&gt;, F&lt;Bs...&gt; &gt;;
        template&lt;typename T, typename... _Us&gt; struct D {
          static constexpr bool v = true;
        };
        template&lt;typename Ts, typename ...&gt; struct H {
          template&lt;typename... Us, bool b =  E&lt;D&lt;Ts, Us&gt;::v...&gt;::v&gt; H(Us&amp;&amp;... us);
        };
        // Error "no instance of constructor ... matches the argument list" here
        H&lt;A&lt;C(int)&gt;&gt; h{1};
        </pre>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6198'>EWARM-6198</a>, <a name='TPB-2948'>TPB-2948</a>]</b>
        In some cases involving <tt>constexpr</tt> constructors of objects with class subobjects, the
        compiler can spuriously emit error Pe028 ("expression must have a constant value") with the
        (incorrect) note "access to uninitialized subobject".
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6184'>EWARM-6184</a>, <a name='TPB-2943'>TPB-2943</a>]</b>
        The constructors and compound assignment operators of the explicit specializations of the
        <tt>std::complex</tt> template (for <tt>float</tt>, <tt>double</tt>, and <tt>long double</tt>) take
        component values by reference instead of by value.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6183'>EWARM-6183</a>]</b>
        Using one of the ACLE intrinsic functions (__arm_rsr, __arm_rsr64, __arm_rsrp, __arm_wsr,
        __arm_wsr64, or __arm_wsrp) to access special registers in a C++ inline function can cause the
        compiler to terminate with an internal error.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6182'>EWARM-6182</a>, <a name='TPB-2944'>TPB-2944</a>]</b>
        A  failed assert doesn't write the argument expression in the output.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6143'>EWARM-6143</a>]</b>
        On optimization level High, the compiler can generate incorrect code when a pointer is assigned a
        value that is equal to it own address. The problem only occurs when compiling for the Thumb2
        instruction set and is more likely to trigger when the assigned pointer is a field in a struct
        variable.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6116'>EWARM-6116</a>, <a name='TPB-2915'>TPB-2915</a>]</b>
        The <tt>#warning</tt> preprocessor directive now generates a separate diagnostic, instead of the
        same one as the <tt>#error</tt> preprocessor directive, only with a different severity.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6085'>EWARM-6085</a>, <a name='TPB-2900'>TPB-2900</a>]</b>
        <p>C++14 <tt>constexpr void</tt> expressions can cause the compiler to terminate with an internal
        error ("[Il2cvm - CollectLiterals]: Unexpected constant kind.").</p>
        <p>Example:</p>
        <div><div>
        <pre>
        constexpr void foo() { }
        int main() { foo(); }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6079'>EWARM-6079</a>, <a name='TPB-2918'>TPB-2918</a>]</b>
        The compiler can terminate with an internal error instead of diagnosing the error when an array is
        declared with a size that is an address cast to an integer type.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6073'>EWARM-6073</a>, <a name='TPB-2896'>TPB-2896</a>]</b>
        <p>On optimization level High, the compiler can generate incorrect code when simplifying address
        expressions in loops, if the address expression is inside another loop that is nested inside the
        first. As an example, consider the loop below. The compiler will simplify the array expression in
        two steps, first in <tt>LOOP C</tt> then in <tt>LOOP A</tt>, but in the second step it moves the
        initialization to a location where <tt>cc</tt> is not defined without replacing it with its initial
        definition. This problem will only occur when there is an extra level of nesting between the
        loops.</p>
        <div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
        <pre class="code-java">
        <span class="code-object">int</span> f(<span class="code-object">int</span> *data, <span
        class="code-object">int</span> x, <span class="code-object">int</span> c, <span
        class="code-object">int</span> rc)
        {
          <span class="code-object">int</span> v = 0;
          /* LOOP A */
          <span class="code-keyword">for</span> (<span class="code-object">int</span> r = 0; r &lt; rc; r++)
          {
            /* LOOP B */
            <span class="code-keyword">while</span> (!v)
            {
              /* LOOP C */
              <span class="code-keyword">for</span> (<span class="code-object">int</span> cc = c + 1; (cc &lt; (c + x)); cc++)
              {
                v = (data[cc * rc + r]);  /* SIMPLIFY */
              }
            }
          }
          <span class="code-keyword">return</span> v;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6044'>EWARM-6044</a>, <a name='TPB-2891'>TPB-2891</a>]</b>
        <p>The following source code gives an erroneous error:</p>
        <div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
        <pre class="code-java">
        <span class="code-keyword">const</span> std::function&lt;<span class="code-object">int</span>*(<span
        class="code-object">int</span>*)&gt; func = [](<span class="code-object">int</span> *pn){ <span
        class="code-keyword">return</span> pn; };
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5827'>EWARM-5827</a>, <a name='TPB-2808'>TPB-2808</a>]</b>
        <p>The parser does not correctly parse function modifiers like <tt>override</tt> when the underlying
        function declarator is parenthesized.</p>
        <p>Example:</p>
        <div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
        panelContent">
        <pre>
        struct A
        {
          virtual void (*f())() = 0;
        };
        struct B : A
        {
          virtual void (*f())() override;
        };
        </pre>
        </div></div>
        </p>
     </li>
</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>
 
 

  <h4><A NAME="his822">V8.22 2018-01-22</A></h4>
  <b>Program corrections</b>
 
<ul>
     <li>
        <p>
        In EWARM 8.22.2<br>
        <b>[<a name='EWARM-6208'>EWARM-6208</a>, <a name='TPB-2953'>TPB-2953</a>]</b>
        <p>Converting a value via a templated conversion operator to an instantiation of the returned class
        template can fail with a misleading error.</p>
        <p>Example:</p>
        <div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
        panelContent">
        <pre>
        template&lt;class T&gt; struct A {};
        struct B
        {
          template&lt;class T&gt; operator A&lt;T&gt;&amp; ();
        };
        struct S {};
        void foo(A&lt;S&gt; &amp;);
        void bar()
        {
          B b;
          foo(b); // Error here
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.22.2<br>
        <b>[<a name='EWARM-6192'>EWARM-6192</a>, <a name='TPB-2945'>TPB-2945</a>]</b>
        The compiler can in some circumstances incorrectly fold expressions containing a subscript applied
        to an integer cast to pointer type.
        <p>Example:</p>
        <div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent
        panelContent">
        <pre>
        int *p = &amp;((int*)0x1000)[1];
        </pre>
        </div></div>
        <p>Expressions like this will sometimes result in a pointer value without the offset.</p>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6130'>EWARM-6130</a>, <a name='TPB-2919'>TPB-2919</a>]</b>
        <p>On optimization level High, the compiler can generate incorrect code for loops when 1) The number
        of laps in the loop can be expressed as a simple arithmetic expression that contains one of the
        variables updated in the loop, 2) The initial value of this variable is an expression that contains
        another variable that is also updated in the loop, and 3) The updates that the loop performs on both
        these variables can be replaced by arithmetic expressions that contain the number of laps.</p>
        <p>An example that triggers the bug is shown below. Note that 1) The number of laps in the loop is
        <tt>n  = x / 10</tt>. 2) The initial value of <tt>x</tt> is <tt>x = y / 10</tt> and <tt>y</tt> is
        modified in the loop. 3) The loop can be replaced with <tt>x = x - 10 * n</tt> and <tt>y = y - 100 *
        n</tt>.</p>
        <div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
        <pre class="code-java">
        unsigned <span class="code-object">int</span> x;
        unsigned <span class="code-object">int</span> y = 4712;
        <span class="code-object">int</span> f(void)
        {
          x = (y / 10);
          <span class="code-keyword">while</span> (x &gt;= 10)
          {
            x -= 10;
            y -= 100;
          }
          <span class="code-keyword">return</span> x;
        }
        </pre>
        </div></div>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6128'>EWARM-6128</a>, <a name='TPB-2920'>TPB-2920</a>]</b>
        When generating list files in Raw encoding or the system default locale encoding, the compiler can
        emit an erroneous warning (Ms014) about being unable to correctly encode some characters.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6109'>EWARM-6109</a>]</b>
        If a function parameter (or return value) is a "Homogeneous Aggregate" that should be passed in VFP
        registers, it can instead be passed in core registers (or on the stack). See "Procedure Call
        Standard for the ARM Architecture" for the definition of a "Homogeneous Aggregate".
        <p>A composite type that is not correctly identified as a homogeneous aggregate due to this bug is
        (or contains) a type that has two fields that do not have the same type. For example:</p>
        <div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
        <pre class="code-java">
        struct { <span class="code-object">float</span> fa[2]; <span class="code-object">float</span> f1; <span class="code-object">float</span> f2; } Homogeneous_Aggregate;
        </pre>
        </div></div>
        <p>The type above is not symmetrical: the field <tt>fa</tt> has type <tt>float[2]</tt>, but the
        fields <tt>f1</tt> and <tt>f2</tt> do not.</p>
        <p>A compiler with this bug is compatible with other compiler versions with this bug. For the highly
        specific cases described above, a compiler with this bug is however not compatible with a compiler
        that does not have this bug.</p>
        <p>A runtime failure can occur if the caller and callee are implemented in different modules, and
        the modules are compiled with incompatible compilers.</p>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6069'>EWARM-6069</a>]</b>
        When the runtime support library for ARMv7-A/R <tt>rt7Sx_tl.a</tt> is specified on the linker
        command line for an application using division, the linker can report "Error[Lt039]: Incompatible
        architecture attributes" also in cases when there is no incompatibility.
        <p>This bug can cause the linker to produce a faulty binary without reporting an error. The binary
        will be faulty in the sense that it contains the <tt>UDIV</tt> instruction also for a core that does
        not support that instruction. This can happen if all of the following conditions are fulfilled:</p>
        <ul>
        <li>One of the runtime support libraries <tt>rt7Sx_tl.a</tt> or <tt>rt5E_al.a</tt> is specified
        explicitly on the linker command line (or one of the big-endian variants, <tt>rt7Sx_tb.a</tt> or
        <tt>rt5E_ab.a</tt>).</li>
        <li>Some library used by the application, and selected by the automatic library selection, uses a
        library division routine. If this library is specified on the command line, error Lt039 is
        reported.</li>
        <li>The target CPU does not support the <tt>UDIV</tt> instruction in Thumb mode.</li>
        <li>The application itself has no reference to any of the library division routines. If it does,
        error Lt039 will be reported.</li>
        </ul>
        <p>Note that division by a constant can be optimized to use multiplication (optimization level
        High), which reduces the number of references to division routines from an application.</p>
        <p>The library routines that use integer division include the <tt>printf</tt> family of routines,
        and several software floating-point routines.</p>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6052'>EWARM-6052</a>]</b>
        A call to an intrinsic function from an inline function that is compiled as Arm mode by default on a
        target where the intrinsic function is not available in Thumb mode erroneously gives the
        compile-time error [Ta097]. This only happens with C99 inlining.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-6034'>EWARM-6034</a>, <a name='TPB-2907'>TPB-2907</a>]</b>
        The compiler can terminate with an internal error ("assertion failed: compare_constants: bad
        constant kind") in some cases involving compound literals in <tt>||</tt> or <tt>&amp;&amp;</tt>
        expressions.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5945'>EWARM-5945</a>]</b>
        When compiling for Thumb (not Thumb2), a reference to a table of strings with an <br/>
        expression like <tt>[x - 1]</tt> can result in linking error "Error[Lp002]: relocation failed: value
        out of range or illegal".
        </p>
     </li>
</ul>
 
  <b>New features</b>
 
<ul>
  <li><p>None</p></li>
</ul>
 


  <h4><A NAME="his820">V8.20 2017-10-16</A></h4>
  <b>Program corrections</b>
 
<ul>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-6013'>EWARM-6013</a>, <a name='TPB-2874'>TPB-2874</a>]</b>
        The compiler could terminate with an internal error (...<tt>decl_inits.c, line 5177</tt>) when using a braced initializer for a member array of objects with constructors.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5993'>EWARM-5993</a>, <a name='TPB-2871'>TPB-2871</a>]</b>
        Member variables in constant and constexpr-declared objects of types with constexpr-declared constructors will not be recognized as constant when identifying known values. This leads to   very inefficient (but still correct) code for this case.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5985'>EWARM-5985</a>, <a name='TPB-2908'>TPB-2908</a>]</b>
        On optimization level High, a negative constant offset in an index expression with an unsigned type smaller than int will change into a positive offset. 
        For example, if the index expression type is unsigned char, the expression <code>i - 15u</code> becomes <code>(int)i + 240</code>. 
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5984'>EWARM-5984</a>, <a name='TPB-2854'>TPB-2854</a>]</b>
        On optimization level High and above, the analysis in the compiler can fail to account for updates to fields in struct variables, if the update is performed in an inlined function. This can make the compiler erroneously infer that this field has a constant value.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5941'>EWARM-5941</a>]</b>
        On optimization level High and above, the compiler can generate erroneous output for min and max expressions, for example <tt>x &lt; y ? x : y</tt>, if one of the values is constant.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5937'>EWARM-5937</a>, <a name='TPB-2845'>TPB-2845</a>]</b>
        On optimization level Medium and above, the order in which variables with static storage duration are placed in the output file is not deterministic. This has no effect on the correctness of the code.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5932'>EWARM-5932</a>, <a name='TPB-2835'>TPB-2835</a>]</b>
        The compiler might generate incorrect exception information for function calls that return an aggregate type through a return value pointer, if either the result is placed in a variable that has an alias or if the destination address is complex to compute, and the calling convention is such that the return value pointer is not returned from the function.
        </p>
     </li>
     <li>
        <p>
        In EWARM 8.20.2<br>
        <b>[<a name='EWARM-5842'>EWARM-5842</a>, <a name='TPB-2830'>TPB-2830</a>]</b>
        When using <tt>--no_static_destruction</tt> and there is a thread local variable needing destruction, the compiler can terminate with an internal error (assertion failed at "...\lower_init.c", line 21513).
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5947'>EWARM-5947</a>, <a name='TPB-2828'>TPB-2828</a>]</b>
        The optimizer combines shifts operations (&lt;&lt;  or  &gt;&gt;) distributed in a binary expression (+  -  &amp;  |  ^) even though the shift counts are not identical. An example with ‘+’ as the binary operator and left shifts in both arguments:<br/>
<tt>((c*16)&lt;&lt;1) + (((c-1)*4)&lt;&lt;1)</tt> is first simplified to <br/>
<tt>(c&lt;&lt;5) + ((c-1)&lt;&lt;3)</tt> which is then incorrectly rewritten as <br/>
<tt>(c + c-1)&lt;&lt;3</tt><br/>
This error occurs if both shift counts are simplified expressions in themselves, as in the example above. The expression can be explicit in the source code or the result of previous optimizations. Because of this, there is no effective workaround.
        </p>
     </li>
	 
     <li>
        <p>
        <b>[<a name='EWARM-5927'>EWARM-5927</a>, <a name='TPB-2841'>TPB-2841</a>]</b>
        Some partial template class specializations, that differ only in decltype expressions, are incorrectly considered identical by the compiler.

<p>Example:</p>

<div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent panelContent">
<pre>   template&lt;class Ty&gt; Ty declval();

   template&lt;bool a&gt; struct b {};

   template&lt;&gt; struct b&lt;true&gt; {typedef void type;};

   template&lt;typename T1, typename T2 = void&gt; struct d;

   template&lt;typename U&gt; struct d&lt;U, b&lt;decltype(f(declval&lt;U&gt;()))::g&gt;&gt; {};

   template&lt;typename U&gt; struct d&lt;U, b&lt;decltype(f(declval&lt;U&gt;(), declval&lt;U&gt;()))::g&gt;&gt; {};

</pre>
</div></div>

<p>The final two partial specializations are incorrectly considered identical.</p>
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5874'>EWARM-5874</a>, <a name='TPB-2825'>TPB-2825</a>]</b>
        The compiler can fail to emit code to properly initialize other members when compiling a constructor for a class that has an anonymous <tt>struct</tt> (an IAR extension) inside an anonymous <tt>union</tt> member.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5855'>EWARM-5855</a>, <a name='TPB-2820'>TPB-2820</a>]</b>
        The compiler sometimes failed to update the debug information for variables whose storage location changed, for example by being moved from the stack into a processor register.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5833'>EWARM-5833</a>, <a name='TPB-2809'>TPB-2809</a>]</b>
        The compiler can terminate with an internal error ("[GoMain - CheckScopes]: Incorrect scope information from parser.") in some cases involving <tt>std::initializer_list</tt> constructors with default parameters.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5825'>EWARM-5825</a>, <a name='TPB-2804'>TPB-2804</a>]</b>
        The compiler can issue spurious errors when compiling a <tt>constexpr</tt> constructor for a class that uses an anonymous struct (an IAR extension) inside an anonymous union.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5803'>EWARM-5803</a>]</b>
        Compiling a function where the accumulated size of stack variables is large (more than 1024 bytes) can result in an internal error.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5797'>EWARM-5797</a>, <a name='EW26712'>EW26712</a>]</b>
        A compiler-internal error could occur when compiling for VFP, for example if a value consisting of four <tt>double</tt> values is copied. The problem can occur for 64-bit, 128-bit, and 256-bit containers, that is: two <tt>float</tt> values, two <tt>double</tt> values, four <tt>float</tt> values, or four <tt>double</tt> values.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5747'>EWARM-5747</a>, <a name='EW26638'>EW26638</a>]</b>
        iarchive terminates with an internal error if any of the paths uses non-ascii characters.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5741'>EWARM-5741</a>, <a name='EW26627'>EW26627</a>]</b>
        The compiler can terminate with an internal error in some cases when _<em>section_begin/</em>_section_end is used in an expression with a constant offset.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5736'>EWARM-5736</a>, <a name='EW26616'>EW26616</a>]</b>
        The MISRA-C:2004 rule 5.2 is triggered if a parameter name in a function declaration is the same as a variable in the enclosing block.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5702'>EWARM-5702</a>, <a name='EW26550'>EW26550</a>]</b>
        On optimization level -Om and above the compiler can generate erroneous  code for <tt>strcmp</tt> when the parameters are pointers to constant strings and at least one of the pointers doesn't point to the beginning of the corresponding string.
        </p>
     </li>
     <li>
        <p>
        <b>[<a name='EWARM-5701'>EWARM-5701</a>, <a name='EW26548'>EW26548</a>]</b>
        A function containing a call to itself, and the recursive call is followed by a <tt>switch</tt>, can trigger an internal error on optimization level Medium or High.
        </p>
     </li>
	 <li>
	    <p>
		<b>[<a name='EWARM-5570'>EWARM-5570</a>, <a name='EW26345'>EW26345</a>]</b>
        An internal error would occur when compiling an inline assembler statement with a 
        VFP instruction within an IT-block for a target that does not support VFP.
	 </li>
     <li>
        <p>
        <b>[<a name='EWARM-5269'>EWARM-5269</a>, <a name='EW25735'>EW25735</a>]</b>
        The life time of variables on the stack are not handled correctly over calls to setjmp. This may cause two variables with non-overlapping life times to be assigned the same location on the stack and the value might not be preserved for the variable live at the setjmp call.
        </p>
     </li>
</ul>
 
  <b>New features</b>
 <ul>
  <li><p><b>Initial support for the  Arm v8-R architecture</b><br />
         This release provides basic supports for the Arm v8-R/R52 architecture.
  </p></li>
  <li><p><b>Stack protection</b><br />
         The IAR C/C++ compiler for Arm now supports stack protection. A canary value will be placed 
         between the stack variables and the return address so that the system can detect corruption 
         of a function return address before the function returns to that address. The compiler will 
         use heuristic to determine whether a function needs stack protection or not. If any defined 
         local variable has the array type or a structure type that contains a member of array type, 
         the function will need stack protection.
  </p></li>
</ul>
 	
	
  <h4><A NAME="his811">V8.11 2017-04-11</A></h4>
  <b>Program corrections</b>
 
<ul>
  <li><p>
    On all optimization levels, the compiler can generate incorrect code for assignment to bitfield members if the right-hand sign expression updates any variable, for example by using post-increment. A typical example triggering the bug is shown below.<br>
    <div class="code panel" style="border-width: 1px;"><div class="codeContent panelContent">
    <pre class="code-java">
    #include <stdio.h>
    
    struct A {
    int a;
    int b:8;
    };
   
    int main(void)
    {
      struct A v1 = {0,1};
      struct A v2 = {2,3};
      
      v2.b = v1.a++;
      
      if(v2.b == 0) {
        printf("OK\n");
      } else {
        printf("BAD\n");
      }
      return 0;
    }
    </pre></div></div>
    [EWARM-6162, TPB-2942]
  </p></li>
  
  <li><p>
    On optimization level High, speed, <code>do</code> loops with a post increment or 
    post decrement operation in the loop test can be optimized incorrectly.<br>
    [EW26455]
  </p></li>
    
  <li><p>
    In some very rare cases the compiler can end up in an infinite loop.<br>
    [EW26475]
  </p></li>

  <li><p>
    Modulo expressions where the divisor is <code>-1</code> or <code>U{CHAR,SHRT,INT,LONG}_MAX</code> 
    are not handled when the divisor is extended to a larger unsigned type.<br>
    [EW26479]
  </p></li>

  <li><p>
    On optimization level High a <code>for</code> or <code>while</code> loop that is preceded 
    by an <code>if</code> statement where the condition is identical to the loop condition can 
    be optimized incorrectly, if any of the variables in the test is modified between the if 
    statement and the loop test, and the variable has a type that is smaller than <code>int</code>.<br>
    [EW26492]
  </p></li>

  <li><p>
    The AFE1 assembler cannot handle characters in comments with values over 
    <code>0x7F</code> in default mode.<br>
    [EW26495]
  </p></li>
  
  <li><p>
    In EWARM 8.11.2:<br>
    Sometimes <code>vget_lane_xxx</code> or <code>vgetq_lane_xxx</code> can generate internal error.
    [EW26156]
  </p></li>
  
  <li><p>
    In EWARM 8.11.2:<br>
    When compiling large functions for Thumb-2 it can happen that two basic blocks
    are more than 1Mb apart, so that a conditional wide branch cannot reach.
    Previously the compiler would fail, either by not terminating, or by reporting
    an internal error. This is now handled by using two instructions.<br>
    [EW26189]
  </p></li>
  
  <li><p>
    In EWARM 8.11.2:<br>
    When compiling for a core that has VFP, but does not have NEON, accessing an object 
    of type T1 in an object of type T2 could lead to internal error if the type T2 consists 
    of two objects of type T1, and T1 consists of two objects of type double.<br>
    [EW26205]
  </p></li>
  
  <li><p>
    In EWARM 8.11.2:<br>
    The compiler can terminate with an internal error in C++ mode when an assignment to 
    a structure with bitfields is made using list-initialization.<br>
    [EW26520]
  </p></li>

  <li><p>
    In EWARM 8.11.2:<br>
    In some rare cases, conditions where a variable is compared to a constant can be optimized 
    incorrectly on optimization level High or Medium.<br>
    [EW26525]
  </p></li>

  <li><p>
    In EWARM 8.11.2:<br>
    The function <code>isblank()</code> incorrectly returns true for characters that 
    <code>isspace()</code> returns true for.<br>
    [EW26556]
  </p></li>

  <li><p>
    In EWARM 8.11.2:<br>
    Variables defined with <code>__ro_placement</code> are not accessed correctly when 
    compiled for <code>RWPI</code>.<br>
    [EW26569]
  </p></li>
  
  <li><p>
    In EWARM 8.11.2:<br>
    The functions <code>iswctype</code> and <code>wctype</code> are missing functionality 
    for the blank operator.<br>
    [EW26581]
  </p></li>

  <li><p>
    In EWARM 8.11.2:<br>
    <code>putchar(-1)</code> erroneously assumes that <code>-1</code> is <code>EOF</code> when 
    the standard says it should be handled as the character <code>0xFF</code>.<br>
    [EW26588]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    On optimization level High, the compiler can generate invalid code for dereferencing 
    a pointer when the pointer is the result of an arithemtic expression containing 
    subtraction.<br>
    [EW26629]
  </p></li>  
  
  <li><p>
    In EWARM 8.11.3:<br>
    A generated thunk call with a structure parameter larger than four bytes and not 
    an even four bytes in size could cause an internal error.<br>
    [EW26633]
  </p></li>
  
  <li><p>
    In EWARM 8.11.3:<br>
    If an ELF-segment has a size of 0 bytes and the last line in the Intel-hex/Motorola 
    S-record file of the immediately preceeding segment contains less than 16 payload bytes, 
    the incomplete line is not output and the bytes that should reside there are lost.<br>
    This problem was introduced in version V10.1.4.185.<br>
    [EW26644]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    On optimization level High, code can be optimized incorrectly if it contains multiple 
    accesses to the same array element (<code>a[i]</code>) and one of the accesses occurs where 
    the optimizer can compute a constant value for the index expression 
    (for example: <code>if (i == 42) x += a[i]</code>.<br>
    [EW26655]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    When compiling for targets with dsp-extensions the compiler can generate a signed multiplication 
    instruction for multiplying two unsigned values shifted 16-steps right.<br>
    [EW26663]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    On optimization level Medium and above, the compiler erroneously optimizes as if static 
    variables declared as <code>__no_init</code> were zero-initialized.<br>
    [EW26692]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    On optimization level Medium and above, the compiler sometimes generates erroneous output 
    for code containing a switch statement where the expression dereferences a pointer 
    that later will be incremented.<br>
    [EW26713]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    Zero-initialized absolute variables are treated as if they were <code>__no_init</code> 
    (not initialized at program startup).<br>
    [EW26715]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    Value initialization (which is what happens to objects whose initializer is an empty 
    set of parentheses) of an array of objects, some of whose subobjects have a user-provided 
    default constructor, incorrectly does not zero-initialize the other subobjects.<br>
    [EW26717]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    The compiler option <code>--no_unaligned_access</code> is not honored for Thumb-2 when 
    performing a structure copy on two-byte structures.<br>
    [EWARM-5810, EW26735]
  </p></li>


  <li><p>
    In EWARM 8.11.3:<br>
    On optimization level High, code can be optimized incorrectly if it contains multiple 
	accesses to the same array element (<code>a[i]</code>) and one of the accesses occurs 
	where the optimizer can compute a constant value for the index expression 
	(for example: <code>if (i == 42) x += a[i];</code>).
    [EWARM-5761, TPB-2775]
  </p></li>


  <li><p>
    In EWARM 8.11.3:<br>
	Complex expressions involving a negation of a subtraction where one of the terms is a 
	multiplication where one of the factors is a subtraction can be optimized incorrectly, 
	on optimization level high.

    Example: <code>return (- ( ((x - y) * - 2) - z) ) / 48;</code><br>

    The compiler makes a silent code generation error when optimizing a complex expression 
	involving a unary negation, a constant, and several binary operations. If the compiler, 
	during the optimization, transforms the expression so that the constant gets negated 
	the code generation can be faulty.<br>
    [EWARM-5740, EW26625]
  </p></li>

  <li><p>
    In EWARM 8.11.3:<br>
    The initialization code for C-RUN (bounds checking) included unaligned accesses.<br>
    [EWARM-5861]
  </p></li>
</ul>

  
  <b>New features</b>
  <ul> 
      <li><p><b>Cortex-R8</b><br/>
          Support for code generation and debugging of ARM Cortex-R8 cores.
      </p></li> 
  </ul>
 
  <h4><A NAME="his810">V8.10 2017-03-10</A></h4>
  <b>Program corrections</b>
 
<ul>
  <li><p>
    Initializing an array of aggregates, parts of which are plain-old-data, with a 
    braced initializer list with fewer entries than the number of elements in the array 
    could cause the compiler to terminate with an internal error (assertion failed in decl_inits.c).<br>
    [EW26298]
  </p></li>

  <li><p>
    A function containing two (or more) identical tests that occur in or as arithmetic 
    expressions can in some cases be optimized incorrectly on optimization level High.<br>
    [EW26325]
  </p></li>

  <li><p>
    On optimization level Medium or High accesses to a <code>const __weak</code> structure 
    or array variables can be optimized incorrectly.<br>
    [EW26346]
  </p></li>

  <li><p>
    Missing an <code>ENDM</code> when recording a macro causes an internal error when 
    using the macro.<br>
    [EW26360]
  </p></li>

  <li><p>
    The template project for rebuilding DLIB libraries contained a file difftime_i.c, 
    which requires a header file that is not included in the distribution. 
    The file difftime_i.c is no longer part of the project.<br>
    [EW26372]
  </p></li>

  <li><p>
    Some complex array address expressions can trigger an internal error.<br>
    [EW26388]
  </p></li>

  <li><p>
    Warning Pe111 (statement is unreachable) is incorrectly not issued for code after 
    a call to a noreturn function.<br>
    [EW26389]
  </p></li>

  <li><p>
    In rare cases the intra-crossjump optimization can remove code that is still used.<br>
    [EW26429]
  </p></li>

  <li><p>
    Variables with static or thread storage duration can be optimized incorrectly 
    on optimization level Medium or High, if they are incremented or decremented with 
    a constant amount and there is only a single use in the rest of the function.<br>
    [EW26446]
  </p></li>

  <li><p>
    Functions where the address of an array with automatic storage duration is 
    passed to an inline assembler statement can be optimized incorrectly on 
    optimization level High.<br>
    [EW26448]
  </p></li>
  
  <li><p>
    The compiler might produce an internal error after a Pe291 error, "no default 
    constructor exists for class X".<br>
    [EW26522]
  </p></li>

  <li><p>
    The square root function in the floating point library returns <code>+0.0</code> 
    for <code>sqrt(-0.0)</code> and not <code>-0.0</code> as the standard specifies.<br>
    [EW26590]
  </p></li>

  <li><p>
    The compiler cannot concatenate wide string literals with character string literals.<br>
    [EW26602]
  </p></li>

  <li><p>
    <code>cosh(Inf)</code> doesn't set <code>errno</code> to <code>EDOM</code>.<br>
    [EW26608]
  </p></li>

</ul>
 
 
  <b>New features</b>
 
<ul>
<li><p><b>Support for the C11 language standard</b><br>
      The compiler and libraries add support for the latest C language standard ISO/IEC 9899:2012.<br>
      <ul>
        <li>The new C library binary object interface is incompatible with earlier EWARM versions.</li>
        <li>C11 is the default language. C89 may be used as well (not 100% backwards compatible).</li>
        <li>The C11 thread mechanism is not supported, and <code>atomic</code> is only supported for certain ARM cores.</li>
        <li>Support for TLS variables and secure C functionality is included.</li>
      </ul>
   </p></li>    
  <li><p><b>Support for the C++14 language standard</b><br>
      The compiler and libraries now support the latest C++ standard ISO/IEC 14882:2015.</li>
      <ul>
      <li>The new C++ library binary object interface is incompatible with earlier EWARM versions.</li>
      <li>It is not possible to upgrade an earlier EC++ or earlier C++ application into using the new C++ 
             without porting the code, i.e. the C++ language is not backwards compatible</li>
      <li>The compiler supports C++ with or without exceptions and RTTI.</li>
      <li>The compiler supports <code>atomic</code> for certain ARM cores.</li>
      <li>Embedded C++ and Extended Embedded C++ have been removed.</p></li>
      </ul>
  <li><p>The compiler now has proper support for encodings. This means that you can use UTF-8, UTF-16, 
      UTF-32, or the system locale in strings and characters.</p></li>          
</ul>
 
 

  <h4><A NAME="his780">V7.80 2016-10-17</A></h4>
  <b>Program corrections</b>
 
<ul>
  <li><p>
    The compiler can exit with an internal error when compiling or preprocessing a source file with 
    certain <code>#pragma</code> directives inside a macro argument. Typically this can happen if there is an 
    <code>#include</code> directive inside an unterminated macro invocation.<br>
    [EW26221]
  </p></li>
  
  <li><p>
    On high optimization level, loops equivalent to memcpy, memset, or memclr can be optimized 
    incorrectly if the upper limit in the loop is a function call.<br>
    [EW26223]
  </p></li>
  
  <li><p>
    The Global Optimizer could under certain circumstances generate non-canonical intermediate code. 
    The structure of this (otherwise correct) code was not expected by the code generator, resulting 
    in an internal error.<br>
    [EW26232]
  </p></li>
  
  <li><p>
    On high optimization level, a scalar variable (<code>v</code>)  with automatic storage duration can be optimized incorrectly if <br>
    &#8226; the only visible assignments to <code>v</code> assign it <code>0</code> or <code>1</code>, <br>
    &#8226; the function contains one or more calls that assign <code>v</code> indirectly, <br>
    &#8226; the calls that assign <code>v</code> all have a pragma <code>function effects</code> that states <code>no_state</code>, and <br>
    &#8226; the function masks out the lowest bit of <code>v</code> (as in <code>v &amp; 1</code>).<br>
    [EW26241]
  </p></li>
  
  <li><p>
    The compiler can exit with an internal error if member function code for a class template uses 
    the <code>dynamic_cast</code> operator from or to pointers or references to the class template type itself.<br>
    [EW26248]
  </p></li>
  
  <li><p>
    The optimization of accesses to stack parameters for Thumb-1 code is performed in memory-dependent order. 
    This results in different code generated for small changes of the environment.<br>
    [EW26267]
  </p></li>

  <li><p>
    Using <code>#pragma weak</code> to define a weak alias and then using that alias in the same 
    compilation unit can result in the compiler exiting with an internal error.<br>
    [EW26268]
  </p></li>

  <li><p>
    In EWARM 7.80.2:<br>
    Expressions of the form <code>((S.A &gt;&gt; (32 - N)) | (S.B &lt;&lt; N))</code> could be rewritten 
    as a rotate instruction (<code>ROR</code>), when <code>A</code> and <code>B</code> were fields in 
    the same struct <code>S</code>.<br>
    [EW26210]
  </p></li>

  <li><p>
    In EWARM 7.80.2:<br>
    Solved a locale issue that created problems with Japanese characters in the project file path.<br>
    [EW26278]
  </p></li>

  <li><p>
    In EWARM 7.80.4:<br>
    Initializing an array of aggregates, parts of which are plain-old-data, with a braced initializer 
    list with fewer entries than the number of elements in the array could cause the compiler to
    terminate with an internal error (assertion failed in <code>decl_inits.c</code>).<br>
    [EW]
  </p></li>

  <li><p>
    In EWARM 7.80.4:<br>
    A function that contains two (or more) identical tests that occur in or as arithmetic  
    expressions can in some cases be optimized incorrectly on optimization level High.<br>
    [EW26325]
  </p></li>

  <li><p>
    In EWARM 7.80.4:<br>
    On optimization level Medium or High, accesses to <code>const __weak</code> structure or array 
    variables can be optimized incorrectly.<br>
    [EW26346]
  </p></li>

</ul>


  <h4><A NAME="his770">V7.70 2016-06-17</A></h4>
  <b>Program corrections</b>

<ul>
  <li>
    <p>
      On optimization level High, static variables can be optimized incorrectly, if there 
      are no visible reads from the variable in the translation unit and the address 
      of the variable occurs in the initializer of another variable and the address 
      has been cast to an integer type.<br>
      [EW26045]
    </p>
  </li>
  <li>
    <p>
      Casting a signed character to an unsigned type to a pointer type can 
      trigger an internal error.<br>
      [EW26051]
    </p>
  </li>
  <li>
    <p>
      Internal error when generating VFP code for a multiplication of a <code>short</code> 
      by <code>1.0f</code> converted back to <code>short</code>.<br>
      [EW26068]
    </p>
  </li>
  <li>
    <p>
      When compiling for an ARM core with DSP extensions (architectures ARMv7E-M, ARMv5E), 
      an expression of the form <code>a - ((b * c) >> 32)</code> where <code>a</code> 
      is a 32-bit value and <code>b, c</code> are 64-bit values, can get the wrong result.<br>
      [EW26084]
    </p>
  </li>
  <li>
    <p>
      The assembler-level optimizer could get trapped in a meta-stable state due to a 
      sequencing issue in the flow of control analysis.<br>
      [EW26088]
    </p>
  </li>
  <li>
    <p>
      In EWARM 7.70.2:<br>
      Using path names with national characters (characters outside 7-bit ASCII) in 
      ielftool does not work properly in some circumstances:<br>
      * Specifying  such characters for a raw binary, SimpleCode, or ELF output 
      file results in a file in an incorrect location with an incorrect name.<br>
      * The verbose console output is incorrect in most cases for such characters 
      in input files as well as output files.<br>
      [EW26101]
    </p>
  </li>
  <li>
    <p>
      In EWARM 7.70.2:<br>
      Vectorization of accesses to floating-point numbers does not handle negative 
      scaling or negative increments correctly.<br>
      [EW26170]
    </p>
  </li>
  <li>
    <p>
      In EWARM 7.70.2:<br>
      In some rare cases forced inline functions can trigger an internal error on optimization level Low.<br>
      [EW26172]
    </p>
  </li>
  <li>
    <p>
      In EWARM 7.70.2:<br>
      Loops where the loop counter is incremented both with a loop-invariant non-constant 
      expression and a constant can trigger an internal error on optimization level High.<br>
      [EW26175]
    </p>
  </li>
  <li>
    <p>
      In EWARM 7.70.2:<br>
      When compiling for Thumb-2, inline assembler statements could be placed within an IT block, 
      which would often result in error Ta117 (IT block ends prematurely)<br>
      [EW26200]
    </p>
  </li>
  <li>
    <p>
      In EWARM 7.70.2:<br>
      On optimization level Medium or High, inline assembler statements can be incorrectly optimized  
      if a variable occurs as an output parameter and the variable is assigned prior to the 
      inline assembler statement.<br>
      [EW26201]
    </p>
  </li>
</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
     <p><b>Initial support for the new ARMv8-M architecture</b><br />
      This release supports both the ARMv8-M Baseline and Mainline implementation.
      The ARMv8-M architecture is focused on bringing security to applications in the embedded and IoT market.<br />
      An example project can be found in the directory <code>&lt;installation path&gt;\arm\src\ARMv8M_Secure</code>.
     </p>
     
     <p>This is a quick reference to CMSE related extensions that are available
        but not otherwise documented. We refer to ARM documentation regarding
        the CMSE programming model, see for example the "ARMv8-M Security
        Extensions: Requirements on Development Tools".
     </p>
     <p>The extensions below are only available when building for ARMv8-M,
        baseline (<code>--cpu 8-M.baseline</code>) or mainline (<code>--cpu 8-M.mainline</code>).
     </p>
     <p>The CMSE programming model specifies that secure code and non-secure code
        are built as separate executable files. The level of set-up peformed by
        the secure code and the location of the entry point to non-secure code is
        however not specified in the CMSE programming model, so the two executable
        files must agree on these points in order to interface correctly.
      </p>
      <p>The linker will automatically create a secure gateway veneer for each
        entry function, as determined by the attribute <code>__cmse_nonsecure_entry</code>.
        These veneers are generated in the section <code>Veneer$$CMSE</code>, which should
        be placed in a NSC region. Consult the documentation for your ARMv8-M
        core to determine how to program the SAU (Security Attribute Unit).
      </p>

      <h4>ICCARM attributes related to CMSE</h4>
      <p>ATTRIBUTE <code>__cmse_nonsecure_entry</code><br />
        DESCRIPTION<br />
        When building secure code (using <code>--cmse</code>), use this attribute to declare an
        entry function to secure mode.<br />
        This corresponds to <code>__attribute__((cmse_nonsecure_entry))</code> in the CMSE
        programming model.<br />
        Parameters or return values located on the stack or in VFP registers
        are not supported for functions with this attribute.
      </p>
      <p>ATTRIBUTE <code>__cmse_nonsecure_call</code><br />
        DESCRIPTION<br />
        When building secure code (using <code>--cmse</code>), use this attribute for non-secure
        function calls. This disallows function definitions with this attribute and
        ensures a secure executable file only contains secure function definitions.
        This corresponds to <code>__attribute__((cmse_nonsecure_call))</code> in the CMSE
        programming model.<br />
        Parameters or return values located on the stack or in VFP registers
        are not supported for functions with this attribute.
      </p>

      <h4>ICCARM options related to CMSE</h4>
      <p>OPTION <code>--cmse</code><br />
        Enable CMSE secure object generation<br />
        DESCRIPTION<br />
        This option enables support for creating CMSE secure executable files, using
        the CMSE attributes <code>__cmse_nonsecure_entry</code> and <code>__cmse_nonsecure_call</code>.
        The option <code>--cmse</code> corresponds to <code>-mcmse</code> in the CMSE programming model.
      </p>

      <h4>IASMARM options related to CMSE</h4>
      <p>OPTION <code>--cmse</code><br />
        Enable CMSE secure object generation<br />
        DESCRIPTION<br />
        This option enables the use of instructions that are only available in
        secure mode.
      </p>

      <h4>ILINKARM options related to CMSE</h4>
      <p>OPTION <code>--import_cmse_lib_out FILE|DIRECTORY</code><br />
                 Produce import library for building non-secure image<br />
        DESCRIPTION<br />
        Use this option when linking a secure image, to create an import library
        which is then used when linking a corresponding non-secure image.
        The import library is an object file that consists of a symbol table:
        each symbol specifies the address of a secure gateway for an entry function
        of the same name as the symbol.
      </p>
      <p>OPTION <code>--import_cmse_lib_in FILE</code><br />
                 Read previous version of import library for building non-secure image<br />
        DESCRIPTION<br />
        Use this option when updating an import library. Entry functions that exist
        in the provided import library will be placed at the same address in the
        updated import library.
      </p>
  </li>
</ul>



  <h4><A NAME="his760">V7.60 2016-03-31</A></h4>
  <b>Program corrections</b>
<ul>
  <li>
    <p>
        Some errors in initialization expressions can be diagnosed with error Pe001 (last 
        line of file ends without a newline) instead of the appropriate error. <br>
        Example: <code>union XXX var = 0;</code><br>
        [EW25472]
    </p>
  </li>

  <li>
    <p>
        Instruction scheduling could move a stack access (using a register other than <code>SP</code>) across a 
        stack pointer adjustment, which could lead to a corrupt stack if an interrupt occurs.<br>
        [EW25810]
    </p>
  </li>

  <li>
    <p>
        SPC volatile reads produce a false positive when some part of a volatile 
        read consists of a multi-dimensional array.<br>
        [EW25817]
    </p>
  </li>
  
  <li>
    <p>
        Using the value of a subexpression containing an assignment operator on a bitfield 
        can sometimes cause the compiler to terminate with an internal error.<br>
        [EW25853]
    </p>
  </li>
  
  <li>
    <p>
        When simplifying expressions looking like <code>(x & c1) | (y | (x & c2))</code> the compiler 
        would extract the wrong constant if <code>y</code> was of the form <code>x & {expr}</code>. 
        This in turn would cause the compiler to try to constant-fold <code>c1</code> with a 
        non-constant value resulting in a NULL pointer and an inevitable NULL pointer crash.<br>
        [EW25854]
    </p>
  </li>
 
  <li>
    <p>
        When generating code for VFP, a parameter of a union type consising only of 
        floating-point members of the same type was incorrectly handled as the corresponding 
        struct type. In some cases this would result in an internal error, and in other 
        cases a read of memory after the union.<br>
        [EW25855]
    </p>
  </li>
 
  <li>
    <p>
        In some cases an internal error is reported when generating code in ARM mode for a 
        switch where all integer values within a range have the same destination label, and 
        the distance from the first to the last value in the range cannot be represented as 
        a shifted immediate. Note that due to optimizations, case values that consist of 
        equivalent code could get assigned the same label.<br>
        [EW25860]
    </p>
  </li>
  
  <li>
    <p>
        Functions with block-local static variables that are initialized with a 
        variable address can be optimized incorrectly.<br>
        [EW25864]
    </p>
  </li>
  

  <li>
    <p>
        Some loops with the accumulation pattern could (incorrectly) be vectorized if 
        the loop contained other uses of the accumulator.<br>
        [EW25867]
    </p>
  </li>
  
  <li>
    <p>
        Medium or higher optimization calls to <code>strcmp</code>, where an argument is a 
        reference to an element in a const multi-dimensional char array, can be optimized 
        incorrectly.<br>
        [EW25868]
    </p>
  </li>
  
  <li>
    <p>
        Loops containing an invariant compare to zero can be vectorized incorrectly.<br>
        [EW25871]
    </p>
  </li>
  
  <li>
    <p>
        Using a compound literal as part of the initializer for a block-local static variable 
        in C could cause the compiler to terminate with an internal error in some cases that 
        should have produced an <code>expression must have a constant value</code> error instead.<br>
        [EW25873]
    </p>
  </li>
  
  <li>
    <p>
        Array accesses after the loop counter has been decremented can be vectorized incorrectly.<br>
        [EW25875]
    </p>
  </li>
  
  <li>
    <p>
        A loop can be vectorized incorrectly if it contains references to an auto array 
        used only inside the loop.<br>
        [EW25878]
    </p>
  </li>
  

  <li>
    <p>
        Loops can be vectorized incorrectly if they contain signed <code>short</code> or 
        <code>int &</code> operations with negative constants. (This can occur in bitfield 
        operations where the underlying type is signed.)<br>
        [EW25880]
    </p>
  </li>
 
  <li>
    <p>
        Using a local assembler label with the same name as a hexadecimal constant without 
        the initial <code>'0'</code> in the same inline assembler statement could cause the compiler to 
        terminate with an internal error.<br>
        [EW25882]
    </p>
  </li>
  
 
  <li>
    <p>
        Left-shifting an 8-bit value more than 16 steps could trigger an internal 
        error during vectorization.<br>
        [EW25885]
    </p>
  </li>
  
  <li>
    <p>
        On medium and high optimization, partial accesses to scalar static 
        variables can be optimized incorrectly.<br>
        [EW25890]
    </p>
  </li>
  
  <li>
    <p>
        When the optimization goal is size, a loop containing an array element 
        assignment, where the right hand side is a variable and the same variable 
        occurs in the index expression (<code>a[i] = i</code>), can be optimized incorrectly if 
        the compiler can deduce that the loop body will be executed exactly once.<br>
        [EW25893]
    </p>
  </li>
  
  <li>
    <p>
        No error message is emitted for some unallowed aggregate types (example: a struct with a 
        single zero-length array member).<br>
        [EW25897]
    </p>
  </li>

  <li>
    <p>
        The compiler could terminate with an internal error when compiling a function 
        ending with a conditional loop where the end of the loop cannot be reached.<br>
        [EW25932]
    </p>
  </li>

  <li>
    <p>
        Faulty backtrace information was generated for a non-SWI function definition in Thumb-2, 
        if there was a previous Thumb-2 SWI function definition in the same compilation unit. 
        The known symptom is that instruction stepping in the debugger slows down.<br>
        [EW25945]
  <li>
    <p>
        Functions taking parameters whose types involved the type <code>va_list</code> could be given 
        incompatible mangled names when compiled in full C++ mode when <code>&lt;stdarg.h&gt;</code> 
        (or <code>&lt;cstdarg&gt;</code>) was not included before all other system library headers.<br>
        [EW25962]
    </p>
  </li>

  <li>
    <p>
        Compiling with runtime bounds checking enabled in Thumb mode could make the compiler
        terminate with an internal error (<code>ElfOutput: Stack usage label missing!</code>).<br>
        [EW25981]
    </p>
  </li>
  
  <li>
    <p>
      In EWARM 7.60.2:<br>
      On High optimization, <code>do</code> loops with signed compare in the loop test can be 
      optimized incorrectly.<br>
      [EW25986]
    </p>
  </li>
  
  <li>
    <p>
      In EWARM 7.60.2:<br>
      Optimizing floating-point compares that contain a constant might change the constant slightly 
      too much in rare cases.<br>
      [EW26011]
    </p>
  </li>


  <li>
    <p>
      In EWARM 7.60.2:<br>
      Attempting to clobber a locked register in an inline assembler statement would result in an  
      internal error instead of a more descriptive error message.<br>
      [EW26013]
    </p>
  </li>
  
  <li>
    <p>
      In EWARM 7.60.2:<br>
      When an optimization removes the last use of a callee-saved register, the now unused register 
      is in some cases no longer saved. This changes the stack layout, which was not reflected by 
      DWARF debug information.<br>
      [EW26026]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.60.2:<br>
      The <code>extend-and-add</code> instruction allows the third operand to be rotated before extending but 
      this was overlooked in the optimization code, causing the compiler to crash when the operand 
      was rotated.<br>
      [EW26027]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.60.2:<br>
      In <code>--macro_positions_in_diagnostics</code> mode, using <code>_Pragma(""diag_xxx = ..."")</code> in a macro does 
      not have the expected effect on diagnostics caused in the rest of the expansion of the macro.<br>
      [EW26032]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.60.2:<br>
      The compiler sometimes retains some unnecessary writes to the virtual function table pointer 
      in constructors for abstract classes that previous versions of the compiler managed to remove.<br>
      [EW26038]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.60.2:<br>
      Compiling with <code>--no_unaligned_access</code> could result in an internal error for example when indexing 
      an array with unaligned 2-byte elements (the problem occurrs when an offset register is used in 
      the two <code>LDRB/STRB</code> instructions used to load/store the unaligned 2-byte element).<br>
      [EW26042]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.60.2:<br>
      In rare cases a volatile inline assembler statement could be removed if it was legal to remove the 
      corresponding non-volatile inline assembler statement. This could happen only when a copy of the inline 
      assembler statement was introduced by some optimization: the volatile attribute of the copy would be
      memory dependent (uninitialized).<br>
      [EW26047]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.60.2:<br>
      Static storage duration variables of reference type initialized to an lvalue are not placed in ROM.<br>
      [EW26076]
    </p>
  </li>
  
</ul>


  <h4><A NAME="his750">V7.50 2015-11-10</A></h4>
  <b>Program corrections</b>
<ul>
  <li>
    <p>
      Variables that are placed in a user-specified section/segment and explicitly initialized with 
      a zero value are incorrectly optimized by the compiler to be zero init instead of copy init.<br>
      [EW25498]
    </p>
  </li>

  <li>
    <p>
      The debug heap is now better at detecting erroneous writes outside allocated heap space. 
      Erroneous writes can still go undetected but more of them are now detected.<br>
      [EW25682]
    </p>
  </li>

  <li>
    <p>
      When performing heap leak checking, a heap block with a payload size of 0 (typically the result of a 
      <code>malloc(0)</code> call) is always considered to be leaked.<br>
      [EW25684]
    </p>
  </li>

  <li>
    <p>
      When performing heap leak checking and the delay list is active, all heap blocks on the delay 
      list are reported as leaked.<br>
      [EW25685]
    </p>
  </li>

  <li>
    <p>
      When compiling for VFP, the <code>VLDR</code> instruction is in some cases used for loading (possibly) unaligned data, 
      which can happen when <code>__packed</code> or <code>#pragma pack</code> is used, The result is a 
      "hard fault" interrupt in cases where the address is actually unaligned.<br>
      [EW25708]
    </p>
  </li>

  <li>
    <p>
      The lifetime of variables on the stack are not handled correctly over calls to <code>setjmp</code>. 
      This might cause two variables with non-overlapping lifetimes to be assigned to the same location 
      on the stack and the value might not be preserved for the variable life at the <code>setjmp</code> call.<br>
      [EW25735]
    </p>
  </li>

  <li>
    <p>
      On optimization level High a use of a variable (v) can be incorrectly optimized if <br>
      1) v's last use for that definition appears in a binary operation with another variable (c), <br>
      2) c is assigned a constant value in one or more of the basic blocks predecessors, <br>
      3) the binary operation is an identity operation for one of the constants that c is assigned, and <br>
      4) v has an indirect definition. <br>
      [EW25739]
    </p>
  </li>

  <li>
    <p>
      <code>Long long</code> additions of <code>0xFFFFFFFF00000000</code> or subtractions of 
      <code>0x100000000</code> can be incorrectly optimized.<br>
      [EW25745]
    </p>
  </li>

  <li>
    <p>
      When generating Thumb-2 code at optimization level High, a byte assignment into an array on the 
      stack can in rare cases result in an unpredictable <code>STRB</code> instruction (the stack
      pointer is used as offset register).<br>
      [EW25778]
    </p>
  </li>
  
  <li>
    <p>
      In EWARM 7.50.2
      The Neon intrinsic function <code>vcombine_&lt;type&gt;(X,Y)</code> can now emit the 
      <code>VSWP</code> instruction when needed.<br>
      [EW25765]
    </p>
  </li>

  <li>
    <p>
      In EWARM 7.50.2
      When vectorization is enabled, a loop containing multiple accesses with pre-/post-decrement 
      through the same pointer variable can trigger an internal error.<br>
      [EW25794]
    </p>
  </li>
  
  <li>
  <p>
    In EWARM 7.50.3:<br>
    On optimization level High, loops can be incorrectly optimized if they contain multiple 
    basic blocks, one or more inline assembler statements, and array accesses passed as 
    arguments to the inline assembler statements.<br>
    [EW25814]
  </p>
  </li>

  <li>
  <p>
    In EWARM 7.50.3:<br>
    On optimization level High, infinite loops can, in some rare cases, cause the compiler 
    to get stuck in an infinite loop.<br>
    [EW25831]
  </p>
  </li>

  <li>
  <p>
    In EWARM 7.50.3:<br>
    Reduction loops can be incorrectly vectorized if they contain casts from <code>char</code> to 
    <code>int</code> (or <code>short</code> to <code>long long</code>).<br>
    [EW25833]
  </p>
  </li>

  <li>
  <p>
    In EWARM 7.50.3:<br>
    On optimization levels Medium and High, an auto array with just one element can in 
    some circumstances trigger an internal error.<br>
    [EW25903]
  </p>
  </li>
</ul>


  <h4><A NAME="his740">V7.40 2015-02-19</A></h4>
  <b>Program corrections</b>
<ul>

<li>
  <p>
    The library function that is used for Cortex-M0/M0+/M1 (ARMv6-M) to multiply two
    single-precision floating-point numbers can for some inputs produce an erroneous
    value for the least significant bit of the result.<br>
    [EW25075]
  </p>
</li>

<li>
  <p>
    Inline assembler did not correctly handle a pseudo-instruction in an IT block, when the pseudo-instruction
    expands to more than one instruction (<code>MOV32</code> expands to two instructions). This only affects
    THUMB mode, and only architectures that have the IT instruction (ARMv6T2, or later: not ARMv6-M).<br>
    [EW25112]
  </p>
</li>

<li>
  <p>
    C-RUN no longer causes a write operation to flash memory when attempting to track bounds for a pointer
    stored at address 0.
    A runtime error is instead reported. The problem has been observed when a Cortex-M vector table is written in C
    or C++: the initial stack pointer is located at address 0, and its bounds are tracked. The solution is to build
    the vector table without tracking of pointer bounds.<br>
    [EW25122]
  </p>
</li>

<li>
  <p>
    In some cases the reduction pattern can trigger an internal error during vectorization.<br>
    [EW25144, EW25154]
  </p>
</li>

<li>
  <p>
    Including <code>stdarg.h</code> is case sensitive. When attempting to include <code>Stdarg.h</code>
    the compiler would include a faulty file. Instead, the compiler now reports
    <code>Fatal error[Pe1696]: cannot open source file</code>.<br>
    [EW25156]
  </p>
</li>

<li>
  <p>
    The compiler can terminate with an internal error when processing the dynamic initialization of a
    <code>const static</code> member variable of POD type of a template class. Example:
<pre><code>template&lt;class T&gt;
struct C
{
  static const int a;
};
extern const int k;
template&lt;class T&gt; const int C&lt;T&gt;::a = k;</code></pre>
    [EW25157]
  </p>
</li>

<li>
  <p>
    A function with <code>#pragma optimize</code> that has both level and goal flags does not get the correct
    optimization.<br>
    [EW25169]
  </p>
</li>

<li>
  <p>
    The normalization loop of the result mantissa had no initial test whether the MSB of the mantissa was set or not.
    In some cases one could get a faulty result and in some rare cases the normalization could end up as an infinite loop.
    This was only a problem for the <code>fmod()</code> function adapted for the ARMv4 instruction set.<br>
    [EW25170]
  </p>
</li>

<li>
  <p>
    When linking a C++ application using exceptions for an ARMv7-M core without VFP and using an explicit
    <code>--cpu</code> option, the linker would report a false error indicating that the exception engine
    in <code>rt7M_tl.a</code> uses VFP instructions incompatible with No vfp.<br>
    [EW25188]
  </p>
</li>

<li>
  <p>
    When compiling with C++ exceptions and VFP support enabled, if a function or function type
    taking a parameter of type <code>std::complex&lt&gt</code> or returning an object of type
    <code>std::complex&lt&gt</code> occurs before the first public variable or function definition
    in a module, the code for that function, or calls to that function type, can be incorrectly generated.<br>
    [EW25215]
  </p>
</li>

<li>
  <p>
    The compiler can terminate with an internal error in some cases, involving aggregate initialization of
    variables with automatic storage duration in template code where at least one aggregate element is not
    a constant.<br>
    [EW25228]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.2:<br>
    The compiler sometimes incorrectly reports a violation of MISRA C:2004 rule 17.4
    (array indexing only with arrays) when accessing an array field of a structure
    variable with static storage duration.<br>
    [EW25240]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.2:<br>
    The compiler can terminate with an internal error when the initialization of a struct variable
    supplies values for a flexible array member at the end.<br>
    [EW25245]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.2:<br>
    Casting the address of a struct variable to another type of struct variable of different size
    and performing a structure assignment can trigger an internal error on optimization level high.<br>
    [EW25249, EW25296]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    Internal error was reported when compiling an empty nested interrupt function for ARMv6
    or newer cores that are not in the architecture profile M.<br>
    [EW25229]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    A function that takes stack parameters and uses a lot of NEON registers in different
    sizes can in some rare circumstances end up with an incorrect offset to the stack variables.<br>
    [EW25336]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    In some very rare cases, automatic function inlining of functions with complex conditional
    code can trigger an internal error.<br>
    [EW25346]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    When the <code>##</code> operator is used between a comma and <code>__VA_ARGS__</code>, and
    <code>__VA_ARGS__</code> expands to no tokens, the compiler incorrectly issues warning Pe1665
    (concatenation does not create a valid token).<br>
    [EW25348]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    Relative relocations are now allowed from within a movable block to outside that movable block,
    if the destination is not movable. The effect is that position-independent code (compiled with
    <code>--ropi</code>) can now call code that is not position-independent.<br>
    [EW25359]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    When using the optimization level High, Size, optimization <code>while (n--)</code> loops can be
    incorrectly optimized. The optimized loop does not execute its final iteration.<br>
    [EW25383]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    The compiler can terminate with an internal error if a static function that has been optimized away
    is used in a <code>#pragma</code> calls directive.<br>
    [EW25387]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    Zero-initialization no longer overwrites the start of the next block when the size of
    zero-initialized data is not a multiple of four.<br>
    [EW25395]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    The <code>VLDR</code> and <code>VSTR</code> instructions are no longer used for unaligned access
    of an integer that is later converted to a floating-point number.<br>
    [EW25407]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    When using the optimization level Medium, optimization a sequence of common subexpressions,
    containing pointer indirections, can be incorrectly optimized if the sequence occurs in
    parallel flows of control.<br>
    [EW25415]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.3:<br>
    Casting the address of a small auto array to a pointer type and assigning the whole array an object
    of another type can in some cases trigger an internal error.<br>
    [EW25442]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    On optimization level High, additions of invariant floating-point values can be hoisted out of loops, even if
    <code>--relaxed_fp</code> was not enabled. This might affect how the values are rounded.<br>
    [EW25450]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    Instruction scheduling can incorrectly move an instruction, for example a store instruction, past an IT block
    containing instructions with side effects that would otherwise prohibit such a move, such as <code>WFI</code>
    or <code>WFE</code>. The effect would in this case be that the store instruction is not executed until after
    the core returns to operating state, instead of before.<br>
    [EW25466]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The declarations for the intrinsic functions <code>__get_LR</code>, <code>__set_LR</code>, <code>__get_SP</code>,
    and <code>__set_SP</code> are missing in the header file <code>intrinsics.h</code>.<br>
    [EW25471]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    In some cases, source code where the <code>::</code> operator is used after something
    that is not a class or a namespace can cause the compiler to terminate with an
    internal error after diagnosing the problem.<br>
    [EW25478]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The compiler can terminate with an internal error if the initialization of a function
    local static storage duration variable extends a flexible array member.<br>
    [EW25483]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The compiler sometimes miscompiles calls via a pointer to member function where
    the member function returns an object by calling a copy constructor.<br>
    [EW25501]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The settings from <code>#pragma default_function_attributes</code> and
    <code>#pragma default_variable_attributes</code> are not reset at the start of each
    compilation unit when using <code>--mfc</code> (multi-file compilation).<br>
    [EW25508]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    Preprocessor output of code using any system header file contains references to a built in type <code>_VA_LIST</code>,
    making the output less useful for further processing than it should be.<br>
    [EW25553]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The compiler can fail with error <code>Pe1152</code> when <code>#pragma weak</code>
    is used and multiple source files are compiled together (<code>--mfc</code>).<br>
    [EW25556]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    Loops with multiple accumulators in the same loop can be incorrectly vectorized.<br>
    [EW25574]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    When compiling for VFP, an assignment between two overlapping homogenous structures containing 
    more than two floating-point numbers can fail.<br>
    [EW25576]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    A read operation of packed short and unsigned short data can give incorrect result if 
    <code>--no_unaligned_access</code> is used with thumb2 code.<br>
    [EW25578]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    C-RUN: In some cases, 64-bit signed multiplication with overflow checking would produce
    a positive result <code>X</code> when the correct result is <code>-X</code>.<br>
    [EW25587]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The optimizer can incorrectly use a value from the initializer of a <code>const __weak</code> 
    symbol.<br>
    [EW25617]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    Casting of a function pointer to an integer is now handled properly.<br>
    [EW25620]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    In some cases when a loop copying from (or to) the stack is recognized and rewritten as a call to
    <code>__aeabi_memcpy</code> (or <code>__aeabi_memcpy4</code>), another stack variable is allocated
    to the same stack location even though they are in scope at the same time.<br>
    [EW25663]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    The optimizations hoist-out-of-if is done in a memory-dependent order.
    This results in different code generated for small changes of the environment.<br>
    [EW25672]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.5:<br>
    When performing heap leak checking and some RAM content is not placed contiguously
    (for example some RAM content on <code>0x20000000</code> and some on <code>0x40000000</code>),
    the leak checker can incorrectly access memory between the areas. This can result in access
    violations and/or spurious diagnostics.<br>
    [EW25683]
  </p>
</li>

<li>
  <p>
    In EWARM 7.40.7:<br>
    In some very rare cases useless instructions could end up in the generated code,
    making it produce unintended results. This has now been fixed.<br>
    [EW25702]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>
 
  <h4><A NAME="his730">V7.30 2014-09-24</A></h4>
  <b>Program corrections</b>
 
<ul>

<li>
  <p>
    The rather naive algorithm for checking whether a symbol is used or not might lead to unexpected warning messages
    from the compiler.<br>
    [EW23132]
  </p>
</li>

<li>
  <p>
    In some cases involving the name of an array in an aggregate initializer with some omitted brackets,
    the compiler can erroneously warn that the array appears to be unused.<br>
    [EW23448]
  </p>
</li>

<li>
  <p>
    The compiler says that it checks MISRA-C:2004 rule 5.4 when it does not.<br>
    [EW24679]
  </p>
</li>

<li>
  <p>
    The compiler gets the size of a parenthesised string literal initializer wrong for a variable
    of unknown array size when clustering is on and the literal is placed as a constant in the code.<br>
    [EW24888]
  </p>
</li>

<li>
  <p>
    Loops that can be replaced by a call to <code>memcpy</code>, <code>memset</code>, or <code>memclr</code> can,
    on <b>High, Size</b> optimization, be incorrectly optimized if the loop test contains a
    post-increment/post-decrement operation.<br>
    [EW24928]
  </p>
</li>

<li>
  <p>
    The MISRA-C:2004 rule 9.2 erroneously triggers for an initializer <code>{0}</code> for a complex type.<br>
    [EW24938]
  </p>
</li>

<li>
  <p>
    The compiler no longer attempts to rename registers within inline assembler instructions.<br>
    [EW24942]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.3:<br>
    Instruction scheduling for ARMv7-M results in an internal error when the last instruction in an <code>IT</code> block
    is a branching instruction, and there is no other control-flow to the branch target.<br>
    [EW24982]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.3:<br>
    MISRA-C:2004 rule 14.2 gives a message for the <code>assert()</code> macro.<br>
    [EW24992]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.3:<br>
    Array expressions where the array address is a known constant value can trigger an internal error when
    vectorization is enabled.<br>
    [EW25012]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.3:<br>
    The compiler can fail to preserve accesses to bitfields where the individual bitfield is declared <code>volatile</code>
    (as opposed to the entire struct/union being declared <code>volatile</code>).<br>
    [EW25020]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.3:<br>
    When designated initializers for members of an anonymous union in EC++/C++ are used in extended language mode,
    the compiler can erroneously emit<code> Error[Pe2358]: a designator for an anonymous union member can only appear
    within braces corresponding to that anonymous union </code>if some braces are omitted.<br>
    [EW25025]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.3:<br>
    The compiler can terminate with an internal error when a <code>char</code> array member is initialized with a string
    literal in a constructor.<br>
    [EW25046]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    On High optimization a loop can be optimized incorrectly, if<br>
    1) a variable (V) is assigned the result of a function call,<br>
    2) the function call is inlined, and<br>
    3) V is used in conditional code that exits the loop with break.<br>
    [EW25027]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    Vectorized code does not handle truncation of right shifts with unknown shift counts correctly.<br>
    [EW25061]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    If vectorization is enabled, an integer variable cast to a pointer type being used as base
    address for an array access can trigger an internal error.<br>
    [EW25067]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    The MISRA-C:2004 rule 5.3 message is mistakenly issued for a <code>typedef</code> situated in a header
    file that is included in two or more source files when compiling in multi-file compilation mode.<br>
    [EW25081]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    <code>static</code> initialized variables placed in a named section (using <code>#pragma location</code>
    or the <code>@</code> operator) that are not referenced in the module can cause an internal error in the compiler.<br>
    [EW25096]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    When computing the minimum or maximum value in a vector, certain patterns with types of different
    sizes can trigger an internal error when vectorization is enabled.<br>
    [EW25102]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    If vectorization is enabled, loops containing a shift with a variable shift
    count can in some cases trigger an internal error.<br>
    [EW25104]
  </p>
</li>

<li>
  <p>
    In EWARM 7.30.4:<br>
    On the High optimization level, loops where the loop variable is postincremented or postdecremented
    in the loop condition can be optimized incorrectly if the loop variable has not be assigned
    in the function.<br>
    [EW25124]
  </p>
</li>

</ul>
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>


  <h4><A NAME="his720">V7.20 2014-05-19</A></h4>
  <b>Program corrections</b>
 
<ul>

<li>
  <p>
    Setting an alignment higher than 16 in a <code>#pragma pack</code> directive can trigger
    an internal error in the compiler.<br>
    [EW24509]
  </p>
</li>

<li>
  <p>
    The <code>strftime</code> library function in <code>time.h</code> cannot be used in AEABI mode.
    Further, <code>time.h</code> can not be included in a C++ source module in AEABI mode.<br>
    [EW24666]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.2:<br>
    Loops that rely on integer overflow in the step expression can in some cases be incorrectly optimized.<br>
    [EW24248, EW24256]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.2:<br>
    A boolean function call can be incorrectly optimized if its result is used in the expression following
    immediately after the function call, and that expression also contains an indirect access through a pointer.<br>
    [EW24710]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.2:<br>
    <code>while</code> loops and <code>for</code> loops with an empty step expression can, in some cases,
    be incorrectly optimized if the last statement in the loop is another loop.<br>
    [EW24742]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.2:<br>
    In EC++/C++, when <code>stdarg.h</code> (or <code>cstdarg</code>) was included before any other standard header,
    <code>(std::)va_list</code> was not defined.<br>
    [EW24746]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.2:<br>
    In some rare circumstances assignments, to global variables or indirect
    assignments through pointers, in conditional code can be optimized incorrectly.<br>
    [EW24748]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.5:<br>
    Runtime checking for unsigned integer overflow might result in a false positive for pre/post-decrement,
    due to an intermediate representation as addition with a negative value which in unsigned arithmetic
    will most often result in overflow.<br>
    [EW24763, EW24851, EW24916]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.5:<br>
    In some cases involving syntax errors in string literals, compilation can fail to terminate or
    terminate with an internal error.<br>
    [EW24806]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.5:<br>
    The common sub-expression optimzation sometimes incorrectly changes the inserted bounds checking code
    into making the compiler produce an internal error.<br>
    [EW24849, EW24853, EW24913]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.5:<br>
    A warning message is corrected, changed <code>to complex</code> into <code>too complex</code>.<br>
    [EW24869]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.5:<br>
    When an auto aggregate is partially initialized by solely non-constant values, the compiler fails
    to emit code to zero-initialize for the remaining parts of the aggregate.<br>
    [EW24920]
  </p>
</li>

<li>
  <p>
    In EWARM 7.20.5:<br>
    At the medium optimization level, code can be incorrectly optimized around function calls in conditions.
    An indirect load that occurs on both paths after the condition can incorrectly be performed before the call.<br>
    For bitfield assignments, other bitfields in the same bitfield container might be reset to the value prior to the call.<br>
    [EW24922]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>


  <h4><A NAME="his710">V7.10 2014-02-21</A></h4>
  <b>Program corrections</b>
 
<ul>

<li>
  <p>
    The error messages <code>Pa053</code> and <code>Pa054</code> now use ELF terminology.<br>
    [EW24093]
  </p>
</li>

<li>
  <p>
    The compiler should issue an error for referring to a struct declared <code>__packed</code>
    if the struct was not defined with <code>__packed</code>. A warning should be emitted when defining a
    struct without <code>__packed</code>, if there was a previous declaration with <code>__packed</code>.
    <code>__packed struct X {...} * x;</code> should not add <code>__packed</code> to both
    <code>struct X</code> and <code>x</code>.<br><br>

    This program correction supersedes the note about the temoporary solution of EW24270 in EWARM 6.70.2,
    which read "IAR extended type attributes before the type in field declarations in C are incorrectly
    applied to the type instead of the field."<br>
    [EW24270]
  </p>
</li>

<li>
  <p>
    Pre- or post-inc (<code>++v</code> or <code>v++</code>) of a variable <code>v</code> placed in a global
    register (using <code>#pragma location</code> or <code>@</code>) would result in internal error.<br>
    [EW24381]
  </p>
</li>

<li>
  <p>
    Generating code for multiplication in Thumb-1 mode could result in internal error.<br>
    [EW24385]
  </p>
</li>

<li>
  <p>
    In some cases, the compiler can terminate with an internal error when reporting an error involving a function.<br>
    [EW24387]
  </p>
</li>

<li>
  <p>
    <code>fileno</code> in the DLIB library will return error status for a legitimite file.<br>
    [EW24393]
  </p>
</li>

<li>
  <p>
    The MISRA-C rule 14.10 is not properly checked when using c99.<br>
    [EW24402]
  </p>
</li>

<li>
  <p>
    The high part of the old value and the low part of the new value could be loaded from a parameter variable
    smaller than 32 bits, if the parameter was passed on the stack and later updated in place.<br>
    [EW24429]
  </p>
</li>

<li>
  <p>
    The loop counter could incorrectly be wrapped in <code>memcpy()</code> for ARMv7-M when building with <code>--no_unaligned_access</code>
    for a small unaligned copy, depending on the data being copied.<br>
    [EW24432]
  </p>
</li>

<li>
  <p>
    An assigment from a variable of a structure type to itself can in some cases result
    in writing to memory immediately following the variable location.<br>
    [EW24458]
  </p>
</li>

<li>
  <p>
    At medium or higher optimization levels a zero-extend can be hoisted out
    of a loop when the extended bits are known to be preserved after bitwise logical operations.
    The optimization is performed also for sign-extend operations, for which
    the extended bits are not known to be preserved.<br>
    [EW24459]
  </p>
</li>

<li>
  <p>
    In a very rare situation, related to static clustering, incorrect code might be generated.<br>
    [EW24464]
  </p>
</li>

<li>
  <p>
    In EWARM 7.10.3:<br>
    In ARM mode, and in Thumb mode for devices with the Thumb-2 ISA, the backtrace adjustment
    for the auto-area might be missing or faulty for some rather large sizes of the auto-area.
    In case this occurrs, C-SPY will show the wrong address for variables placed in the auto-area,
    for example in the Locals window.<br>
    [EW24499]
  </p>
</li>

<li>
  <p>
    In EWARM 7.10.3:<br>
    <code>#pragma default_variable_attributes</code> has no effect on variables with const or volatile type.<br>
    [EW24525]
  </p>
</li>

<li>
  <p>
    In EWARM 7.10.3:<br>
    MISRA C:2004 rule 14.10 erroneously gives an error for the construction<code> if (x) f1(); else { if (y) f2(); }</code>.<br>
    [EW24533]
  </p>
</li>

<li>
  <p>
    In EWARM 7.10.3:<br>
    The compiler can erroneusly report a non-existing violation of MISRA C 2004 rule 14.10
    (final<code> else </code>after<code> if...else if</code>) in some cases involving nested if statements.<br>
    [EW24545]
  </p>
</li>

<li>
  <p>
    In EWARM 7.10.3:<br>
    In some cases the compiler generated code for an expression on the form<code> ~x & (y << k) </code>
    that corresponds to<code> x & ~(y << k)</code>. This would occur when an <code>LSL</code> instruction
    is replaced by a shifted operand within a <code>BIC</code> instruction, and the operands of the <code>BIC</code>
    instruction are swapped even though it is not a commutative operation.<br>
    [EW24548]
  </p>
</li>

<li>
  <p>
    In EWARM 7.10.3:<br>
    When generating code for Thumb-2 a test can go the wrong way for unsigned compare less/greater-than (or equal)
    if one operand is negated and the value for that operand is zero.<br>
    [EW24561]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>


  <h4><A NAME="his670">V6.70 2013-10-29</A></h4>
  <b>Program corrections</b>

<ul>

<li>
  <p>
    On medium and high optimizations, a pointer variable<code> p </code>can be optimized incorrectly
    if<code> p </code>is assigned the address of an array element, where the index expression is an
    other array expression or an indirect load, and the value of the index expression changes between
    the assignment of<code> p </code>and the use(s) of<code> p</code>.<br>
    [EW24173]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    When generating code for Thumb1, any stack accesses that either explicitly or through compiler
    optimizations get a negative offset from SP, will result in an internal error.<br>
    [EW24231]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    Loops containing two or more expressions where the loop variable <code>+/-</code> a constant offset
    is multiplied with a loop-invariant expression, might be incorrecly optimized if the constant offset
    differs between the expressions.<br>
    [EW24238]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    A loop-invariant truncating type conversion could incorrectly be hoisted to a location before a use
    of the value being converted.<br>
    [EW24243]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    When generating code for VFP in Thumb2, if the program contains a code sequece that selects the smallest
    of two floating point values the compiler might issue an internal error.<br>
    [EW24246]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    Putting a partial update of a local short variable at the end of a loop body or a conditional block can
    sometimes make the compiler crash.<br>
    [EW24247]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    A sign- or zero-extend operation can be optimized away if a mask is found that creates a value such that
    the preceding extend has no effect. This can happen also if the mask depends on the extend operation,
    which then produces the wrong value when the extend is removed.<br>
    [EW24255]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    CSmith found a problem that makes the compiler generate incorrect code.
    <ul>
    <li>A packed struct with padding inside just before a bitfield which only uses a part of its container.</li>
    <li>An initializer to a variable of the struct.</li>
    <li>The compiler can deduce the value from the initializer.</li>
    </ul><br>
    If all of the above occurs, the compiler can propagate the wrong value for the bitfield.<br>
    [EW24258]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    On high optimization, masking assignments, like <code>g &= 1</code> used inside an <code>&&</code>
    or <code>||</code> condition might be incorrectly optimized if there are no other uses of <code>g</code>
    inside the function.<br>
    [EW24278]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    Loops with unsigned loop variables that are initialized with negative values might be incorrectly optimized.<br>
    [EW24280]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    Diagnostic column positions can sometimes be incorrect when a complete macro invocation is present
    earlier on the same line.<br>
    [EW24308]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    In non-strict C89/(E)EC++/C++ modes, unsuffixed integer literals larger than <code>LONG_MAX</code>
    but smaller than <code>ULONG_MAX+1</code> are incorrectly given a type of <code>unsigned long</code>
    instead of <code>long long</code>. In particular, when used in an expression with the prefix <code>-</code>
    operator, the result is thus a positive <code>unsigned long</code> value rather than a negative
    <code>long long</code> value, as would be expected. Example: -2388135082 becomes 1906832214.<br>
    [EW24323]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    The compiler does not generate stack usage analysis information for some virtual function calls when multiple
    or virtual inheritance is involved.<br>
    [EW24329]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    For code using C++ pointers to data members, an assertion at <code>lower_il.c</code>, line 13418 can trigger
    erroneously.<br>
    [EW24331]
  </p>
</li>

<li>
  <p>
    In EWARM 6.70.2:<br>
    A MISRA C rule 5.1 (31 significant characters) violation diagnostic message is erroneously emitted for a program
    making use of the IAR Systems runtime routines <code>__iar_unaligned___aeabi_memmove4</code> and
    <code>__iar_unaligned___aeabi_memmove8</code>.<br>
    [EW24337]
  </p>
</li>


</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>
 
 
  <h4><A NAME="his660">V6.60 2013-06-27</A></h4>
  <b>Program corrections</b>
 
<ul>

<li>
  <p>
    A pointer parameter, cast to an integer type, used in a switch expression no longer causes
    an internal error during function inlining.<br>
    [EW23758,EW23941]
  </p>
</li>

<li>
  <p>
    An internal error no longer occurs when compiling C++ with VFP support if there is a flow for
    C++ exceptions to an interrupt function.<br>
    [EW23804]
  </p>
</li>

<li>
  <p>
    MISRA-C:2004 rule 5.4 is now supported correctly.<br>
    [EW23907]
  </p>
</li>

<li>
  <p>
    In some cases when compiling for Thumb2 the compiler did not sign-/zero-extend a 16-bit value as needed before
    performing a right shift, if the shift count was not constant. This has been corrected.<br>
    [EW23961]
  </p>
</li>

<li>
  <p>
    The compiler does not change the underlying MISRA-C:2004 type for an explicit <code>C</code> cast.
    This can generate erroneous MISRA-C:2004 errors for rules that check against the underlying type.<br>
    [EW23988]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    In a leaf function compiled for Thumb2 at high optimization level, in some cases a comparison between
    zero and the result of a multiplication could result in faulty code for the comparison if other statements
    in the function are relatively simple.<br>
    [EW24014]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    Using <code>memcpy</code> to modify the content of an automatic variable of a type shorter than <code>int</code>
    might trigger an internal error in the compiler. Example that triggers the problem:
<pre><code>void f (int *x)
{
  short a;
  memcpy (&a, 0, 0);
  if (a == 1 || a == 2)
    *x = 0;
}</code></pre>
    [EW24037]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    In some very rare cases, two compilations of the same file might not produce identical results.<br>
    [EW24044]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    Reading a 16-bit value from an unaligned source, such as a pointer to packed structure, casting it to
    the opposite signedness and then casting it to a 32-bit value might produce invalid code.<br>
    [EW24066]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    <code>assert()</code> now generates a message. Note, the behaviour is changed in 6.60.2,
    read more in <A href="csarm.ENU.html#important">Release notes for the IAR C-SPY Debugger for ARM</A>.<br>
    [EW24102]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    Specifying a non-static member function in <code>#pragma</code> calls results in error Pe028
    (expression must have a constant value).<br>
    [EW24137]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    When mangling template names, IAR Systems type qualifiers, like <code>__packed</code>, in template type arguments
    are not taken into account, which can lead to internal errors in the compiler, errors when linking, or
    silent use of the wrong code. Example:
<pre>
Given the template
<code>template&lt;typename T&gt; struct X;</code>
both
<code>X&lt;int&gt;</code>
and
<code>X&lt;int __packed&gt;</code>
get the same mangled name.
</pre>
    The bug leads to problems if the same template is instantiated in such a way that the only difference
    is in type qualifiers in its template type arguments. Memory qualifiers are correctly taken into account.<br>
    [EW24140]
  </p>
</li>

<li>
  <p>
    In EWARM 6.60.2:<br>
    A left-shift of a masked result (bitwise AND) of a signed right-shift can sometimes be expressed without
    the right-shift. If the optimization is correct it might still not be performed depending on the order
    between addresses allocated by the OS.<br>
    [EW24143]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>

  <li><p><b>Advanced heap update</b><br>
    Available functionality of the advanced heap is listed in <code>arm\inc\c\iar_dlmalloc.h</code>.
    The statistic functions of the advanced heap can be used through this header file.
  </p></li>

</ul>
 
 
  <h4><A NAME="his650">V6.50 2012-11-10</A></h4>
  <b>Program corrections</b>
 
<ul>

<li>
  <p>
    The calculation of leap days was incorrect in the time system in the library. This has been corrected.<br>
    [EW23273]
  </p>
</li>

<li>
  <p>
    In some rare cases the compiler could end up in an infinite loop. This has been corrected.<br>
    [EW23308, EW23573]
  </p>
</li>

<li>
  <p>
    The compiler no longer terminates with an internal error when
    <code>--macro_positions_in_diagnostics</code> is used.<br>
    [EW23337]
  </p>
</li>

<li>
  <p>
    Incorrect code was generated for varargs constructors in some cases. This has been corrected.<br>
    [EW23358]
  </p>
</li>

<li>
  <p>
    The compiler now generates useful stack backtrace also for a non-returning interrupt function.<br>
    [EW23363]
  </p>
</li>

<li>
  <p>
    The underlying type for the <code>__section_size()</code> (and its alias <code>__segment_size()</code>)
    operator was erroneous. This could lead to, for instance, MISRA-C:2004 rule10.1 errors if that operator
    was used. This has been corrected.<br>
    [EW23390]
  </p>
</li>

<li>
  <p>
    The function prologue/epilogue for an interrupt function (<code>__irq</code> or <code>__fiq</code>) now
    stores/restores also the VFP registers <code>D16</code> through to <code>D31</code>, when available.<br>
    [EW23418]
  </p>
</li>

<li>
  <p>
    The compiler now generates correct debug information for variables placed on the
    stack in functions ending with an infinite loop.<br>
    [EW23422, EW23439]
  </p>
</li>

<li>
  <p>
    If error <code>Pa128</code> (truncating cast in constant expression) was suppressed or turned into
    a warning when casting from a pointer to a smaller integer, the compiler aborted with
    an internal error. This has been corrected.<br>
    [EW23444]
  </p>
</li>

<li>
  <p>
    Accesses to volatile auto structs could be incorrectly optimized. This has been corrected.<br>
    [EW23458]
  </p>
</li>

<li>
  <p>
    Combinations of left shifts, right shifts, multiplications with a power of 2, and
    divisions with a power of 2 in array index expressions could be incorrecly optimized.
    This has been corrected.<br>
    [EW23526]
  </p>
</li>

<li>
  <p>
    An indirect expression through an initialized global or static <code>const</code> pointer could be
    optimized incorrectly. This has been corrected.<br>
    [EW23543]
  </p>
</li>

<li>
  <p>
    An array index expression could be incorrectly optimized if the index expression was used in a
    loop (L), and if a variable (V) was assigned a value that was invariant in L, and V occured multiple
    times in the index expression.<br>
    [EW23571]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    In some rare cases a static or global variable in nested loops could be optimized incorrectly if an inner loop
    contained potential aliasing, for example as a function call or indirect accesses, and the variable was modified
    in both the inner loop and the outer loop. This has been corrected.<br>
    [EW23566]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    Patterns where a pointer to a pointer was used in pointer arithmetics no longer trigger an internal error.<br>
    [EW23579]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    Accesses where the address of an array is cast into a pointer to a data type larger than the element type
    and several array elements are accessed at once, no longer trigger an internal error.<br>
    [EW23581]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    For Cortex-M4F, the standard library call <code>longjmp</code> now restores the VFP registers correctly.<br>
    [EW23583]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    The <code>__iar_Mutex</code> no longer allocates a lock in the normal library.<br>
    [EW23584]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    An address of an auto variable cast to <code>void</code> no longer trigger an internal error.<br>
    [EW23602]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    Right shift (arithmetic as well as logic) no longer cause the <code>ZeroExt</code> property to become negative.<br>
    [EW23613]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.2:<br>
    The files <code>data_init.c</code> (replacing <code>data_init3.c</code>) and <code>rle_init.c</code>
    (replacing <code>rle_init3.c</code>) are no longer missing from the IAR Embedded Workbench installation.<br>
    [EW23616]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.3:<br>
    Partial assignments in the initialization of loop variables could trigger an internal error.
    This has been corrected.<br>
    [EW23634]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.3:<br>
    In ARM mode, a signed comparison of a shifted value with 0, for example <code>(x >> 16) < 0</code>,
    could result in an internal error. This has been corrected.<br>
    [EW23665]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.3:<br>
    The media instruction <code>SMMUL</code> was incorrectly generated for unsigned (zero-extended)
    operands. This has been corrected.<br>
    [EW23682]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.3:<br>
    The header file <code>init_streams.h</code> is now included in the library source code shipped with
    the full product.<br>
    [EW23709]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.3:<br>
    Now the MISRA-C:2004 rule 12.7 uses the underlying type to determine whether the rule has been violated.<br>
    [EW23717]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.4:<br>
    An indirect assignment could be optimized incorrectly if the right hand side expression was masked with a constant
    and the only use was in a test, comparing the value, possibly masked with the same constant as in the assignment
    or a constant with fewer bits set, to zero. For example:<br>
    <code>
    p->foo = x & 0x02;<br>
    ...<br>
    if (p->foo & 0x02)</code><br>
    This has been corrected.<br>
    [EW23796]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.4:<br>
    Loops that contains indirect assignments where the address expression consists of both loop dependent variables
    and loop invariant variables could be optimized incorrectly if the loop was followed by an assignment to the
    same address expression. This has been corrected.<br>
    [EW23815]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.6:<br>
    When compiling for Thumb2 with High optimization level (<code>-Oh</code>, <code>-Ohs</code>, or <code>-Ohz</code>),
    if the value of a <code>switch</code> expression had additional uses after it was evaluated, these uses could in
    some rare cases yield some other value.<br>
    [EW23873]
  </p>
</li>

<li>
  <p>
    In EWARM 6.50.6:<br>
    When using a string literal to initialize an array and the string literal contained too few bytes,
    the compiler did not initialize the last bytes of the array properly. The missing bytes were read
    from after the string literal. This has been corrected.<br>
    [EW23891]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>
    None.
  </li>
</ul>
 
  <h4><A NAME="his640">V6.40 2012-06-05</A></h4>
  <b>Program corrections</b>
 
<ul>

<li>
  <p>
    Using 16-bit and 8-bit integer variables as bitfields no longer causes an internal error.<br>
    [EW22858]
  </p>
</li>

<li>
  <p>
    In some rare cases the compiler could loop when compiling a signed expression containing multiple shifts. This no longer happens.<br>
    [EW22896]
  </p>
</li>

<li>
  <p>
    Using multi-file compilation, <code>--mfc</code>, with files that use inline assembler statements could result in an internal error.<br>
    [EW22905]
  </p>
</li>

<li>
  <p>
    In some rare cases the stack frame of a function could be optimized in such a way that the debug information would be erroneous (off by four, for example).
    This means that in the debugger, a stack variable could appear to reside in some location which will probably not hold the expected value.
    This no longer happens.<br>
    [EW22907]
  </p>
</li>

<li>
  <p>
    A module containing a pointer to a member function constant for a virtual function could in some cases result in a <code>symbol_lookup_M31</code>
    internal error in the compiler for the typeinfo object for the owning class.<br>
    [EW22918]
  </p>
</li>

<li>
  <p>
    A volatile load could incorrectly be removed if it was part of an expression that was shifted so far that none of the bits from the load were used.<br>
    [EW22974]
  </p>
</li>

<li>
  <p>
    An <code>asm</code> statement following immediately after a constructor call caused an internal error.<br>
    [EW22982]
  </p>
</li>

<li>
  <p>
    A Common subexpression elimination (CSE) was erroneously lifted due to faulty bitfield handling. This has been fixed.<br>
    [EW22988]
  </p>
</li>

<li>
  <p>
    Fixed a problem with using <code>#pragma call_graph_root</code> on a <code>__weak</code> function definition. In Thumb mode, the result was an
    internal error in the compiler. In Arm mode, the result was that the linker in some cases used a section symbol (something like <code>.text_17</code>)
    instead of the function symbol for these functions.<br>
    [EW22996]
  </p>
</li>

<li>
  <p>
    An <code>asm</code> statement containing a local label in a function in a module where the function is inlined twice produced an internal error.
    This has been fixed.<br>
    [EW23006]
  </p>
</li>

<li>
  <p>
    The compiler no longer generates <code>IT</code> instructions inside <code>IT</code> blocks, which caused an internal error.<br>
    [EW23020, EW23083]
  </p>
</li>

<li>
  <p>
    Using the address of a C99 compound literal to initialize a pointer in an aggregate caused an internal error in the compiler.<br>
    [EW23021]
  </p>
</li>

<li>
  <p>
    In some rare cases partial accesses were incorrectly optimized.<br>
    [EW23028]
  </p>
</li>

<li>
  <p>
    The compiler had a bug that could cause the display of stack-allocated local variables to be incorrect in debuggers other than C-SPY.<br>
    [EW23042, EW23047]
  </p>
</li>

<li>
  <p>
    Now an <code>unsigned long</code> to an <code>unsigned int</code> cast in a static initializer does not generate an error.<br>
    [EW23054]
  </p>
</li>

<li>
  <p>
    The compiler, the linker, and the elftools returned error status when run without options. This has been fixed.<br>
    [EW23057]
  </p>
</li>

<li>
  <p>
    The cross call optimization could not handle a sequence that started with a label and had one back-jump to that label in the sequence
    and one back-jump to it after the sequence. This has been fixed.<br>
    [EW23063]
  </p>
</li>

<li>
  <p>
    Inline assembler expressions with volatile arguments could fail in register allocation.<br>
    [EW23086]
  </p>
</li>

<li>
  <p>
    In some cases a common subexpression could be hoisted across a condition controlling the execution of the expression.<br>
    [EW23087]
  </p>
</li>

<li>
  <p>
    Index expressions mixing signed and unsigned types could in some rare cases cause an internal error.<br>
    [EW23088]
  </p>
</li>

<li>
  <p>
    The compiler could erroneously inline <code>__weak</code> function definitions.<br>
    [EW23112]
  </p>
</li>

<li>
  <p>
    C-SPY no longer generates an error when the debugged application contains a C symbol with the name c or d.<br>
    [EW23131]
  </p>
</li>

<li>
  <p>
    The choice of using the 64-bit implementation for the time interface did not work when using low optimization levels. This has been fixed.<br>
    [EW23162]
  </p>
</li>

<li>
  <p>
    The compiler issued an internal error when checking the code <code> (void (**)(void)) 1 </code> for violation of the MISRA C:2004 rule 17.5. This has been fixed.<br>
    [EW23164]
  </p>
</li>

<li>
  <p>
    The linker now selects the correct libraries when linking an application without code, also for Cortex-M
    devices.<br>
    [EW23204]
  </p>
</li>

<li>
  <p>
    For Thumb2, at optimization level Medium, expressions of the form <code>(x &gt;&gt; K) & M</code> could result in code
    that cleared too many bits (for a constant <code>K &gt; 0</code> and <code>M = (1 &lt;&lt; N) - 1</code> for a constant
    <code>N &gt; 0</code>).<br>
    [EW23214]
  </p>
</li>

<li>
  <p>
    The endian attribute for pointers and arrays is now supported in the compiler, which makes this issue obsolete.<br>
    [EW23220]
  </p>
</li>

<li>
  <p>
    Fixed a pathological case where a static variable used as index expression in a static array could trigger an internal error.<br>
    [EW23229]
  </p>
</li>

<li>
  <p>
    In EWARM 6.40.2:<br>
    The <code>LDRD</code> instruction could be used for copying an 8-byte <code>struct</code> with less than
    4-byte alignment, which could result in an exception (hard fault) when running the application.
    This no longer occurs.<br>
    [EW23272]
  </p>
</li>

<li>
  <p>
    In EWARM 6.40.2:<br>
    When compiling for Thumb2, a zero-initializer for a single byte array on the stack no longer generates code
    that clears two bytes of memory.<br>
    [EW23298]
  </p>
</li>

<li>
  <p>
    In EWARM 6.40.3:<br>
    A bitwise AND (<code>&</code>) between an 8-bit variable and a constant wider than 8 bits does no longer
    generate an internal error.<br>
    [EW23295, EW23362, EW23365]
  </p>
</li>

<li>
  <p>
    In EWARM 6.40.3:<br>
    In some rare cases multiple tests of the same variable could be incorrectly optimized. This has been corrected.<br>
    [EW23360]
  </p>
</li>

<li>
  <p>
    In EWARM 6.40.3:<br>
    At optimization level medium (or higher), the updates of an address passed to the <code>__PLD</code> or <code>__PLI</code>
    intrinsic functions could be optimized away. This has been corrected.<br>
    [EW23387]
  </p>
</li>

<li>
  <p>
    In EWARM 6.40.4:<br>
    Loops with multiple exit tests (a test containing <code>&&</code> or <code>||</code> counts as multiple tests)
    could be optimized incorrectly, if one test tested a loop counter, another test tested a value loaded indirectly
    from a pointer, and the pointer was incremented or decremented on each iteration through the loop.<br>
    [EW23318]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>
  <li><p>
    <b>Inline assembler</b><br>
    New operand constraints and modifiers.
  </p></li>
  <li><p>
    <b>CMSIS update</b><br>
    CMSIS version 3.01 is now included in the product.
  </p></li>
</ul>
 
  <h4><A NAME="his630">V6.30 2011-10-22</A></h4>
  <b>Program corrections</b>
 
<ul>
<li>
  <p>
    The diagnostic messages now refer to the correct rule numbers
    when MISRA C 2004 is chosen.<br>
    [EW22347]
  </p>
</li>

<li>
  <p>
    The underlying type of a constant expression is now evaluated as
    for any other expressions. This deviates from the specific constant
    expression rule in MISRA-C:2004 6.10.4. Both IAR Systems and the MISRA-C
    committe feels that this rule doesn't reflect the intention.<br>
    [EW22373]
  </p>
</li>

<li>
  <p>
    Initalizing a member <code>char</code> array with a string literal in a class
    constructor no longer results in an internal error.<br>
    [EW22503]
  </p>
</li>

<li>
  <p>
    The intrinsic function <code>__REV16</code> is now available when compiling for Cortex-M0.<br>
    [EW22715]
  </p>
</li>

<li>
  <p>
    Complement <code>~</code> of an unsigned expression is no longer optimized 
    incorrectly when the expression contains a right shift or a bitwise and with a constant.<br>
    [EW22725]
  </p>
</li>

<li>
  <p>
    C++ temporary objects needed when initializing file-scope and namespace-scope
    variables are now created properly.<br>
    [EW22751]
  </p>
</li>

<li>
  <p>
    A signed test for less than, less equal, greater than or greater equal on an expression
    that is shifted immediately before the test now gives correct result.<br>
    [EW22752]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    Using the <code>__packed</code> attribute in situations that involve template functions no longer
    causes an internal error.<br>
    [EW22776]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    On the high optimization level, a mix of signed and unsigned values in complex array index
    expressions no longer causes an internal error.<br>
    [EW22787]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    Passing a constant as argument to an intrinsic function that inserts a specific
    assembler instruction no longer causes an internal error in C++ mode.<br>
    [EW22808]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    In rare cases the induction variable optimization could cause an internal error. This has been corrected.<br>
    [EW22815]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    Using the multi-file compilation option <code>--mfc</code> with one or more zero-size source files
    no longer causes the compiler to terminate with an internal error.<br>
    [EW22828]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    The debug information in ELF files now refers to the correct source file name when the command line option
    <code>--preinclude</code> is used.<br>
    [EW22848]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    When some diagnostics (in particular, the undefined behavior warnings about unordered accesses etc)
    were triggered on uses of fields in a block-local anonymous struct/union variable, the compiler
    aborted with an internal error. This problem has been corrected.<br>
    [EW22850]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    The thread-exit function now correctly deallocates the potentially allocated daylight saving time structure.<br>
    [EW22862]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.3:<br>
    An instructions inside an IT-block is no longer a candidate for dead-code removal, since removing it will leave
    the IT-instruction inconsistent.<br>
    [EW22864]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.5:<br>
    Common subexpression elimination (CSE) could go wrong in rare cases when equivalent bitwise or-expressions
    occurred at multiple locations, and at least one but not all were rewritten as a bitfield instruction.
    This no longer happens.<br>
    [EW22932]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.6:<br>
    A function containing two <code>? :</code> expressions (or equivalent <code>if</code> statements) with
    identical tests where two different variables were assigned the same values could be optimized incorrectly
    if the first variable was reassigned in the basic block following the <code>? :</code> expression.
    This has been corrected.<br>
    [EW22965]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.6:<br>
    The compiler could incorrectly optimize the expression <code>uchar = ~0 (int & 1)</code>.
    This has been corrected.<br>
    [EW22972]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.8:<br>
    Some assignments could be incorrectly optimized if the left-hand side was an indirection (through a pointer or reference) or a global
    or static variable and the right-hand side was a function call. Exceptions thrown from those calls were not correctly handled.<br>
    The optimization intra cross jump did not always create correct code when one of the sequences it tried to optimize was exception code. This has been fixed.<br>
    [EW23094, EW23185]
  </p>
</li>

<li>
  <p>
    In EWARM 6.30.8:<br>
    Range checks, such as <code>((unsigned char) x)-48 < 10</code>, could sometimes be performed without zero-extending the variable <code>x</code>.<br>
    [EW23141]
  </p>
</li>

</ul>
 
 
  <b>New features</b>
 
<ul>
  <li>None.</li>
</ul>
 
  <h4><A NAME="his621">V6.21 2011-07-05</A></h4>
  <b>New features</b>
<ul>
  <li>None.</li>
</ul>

  <b>Program corrections</b>	
<ul>
<li>
  <p>
    Location information (from <code>#pragma location</code> or the <code>@</code> operator) now carries
    over properly from a function declaration to the function definition.<br>
    Example:<br>
      <code>int foo(void) @ "XXX";<br>
      int foo(void) { return 1; }<br></code>
    The function <code>foo()</code> should be placed in the section <code>XXX</code>, but it was not.<br>
    [EW22448]
  </p>
</li>

<li>
  <p>
    Redeclaring <code>main</code> with non-matching location strings and suppressing the resulting error
    caused an internal error in the compiler. Now the error cannot be suppressed in this situation.<br>
    [EW22450]
  </p>
</li>

<li>
  <p>
    Commutative operations with multiple constants are no longer optimized incorrectly even if one or more of the
    operations is of a smaller type.<br>
    [EW22470, EW22484]
  </p>
</li>

<li>
  <p>
    For a nested interrupt handler, <code>LR</code> is now adjusted.<br>
    [EW22472]
  </p>
</li>

<li>
  <p>
    String literals in inline and template functions were turned into non-const variables.
    Now the variables are <code>const</code> instead, and end up in ROM, the way they should.<br>
    [EW22475]
  </p>
</li>

<li>
  <p>
    Corrected an internal error.<br>
    [EW22479]
  </p>
</li>

<li>
  <p>
    In EWARM 6.21.4:<br>
    For certain small switch statements the compiler generated different code for different
    invocations. This has been fixed.<br>
    [EW22520]
  </p>
</li>

<li>
  <p>
    In EWARM 6.21.4:<br>
    In some rare cases a store to a struct member in an auto object was optimized incorrectly
    if the object member was read once before the address of the object was passed to a function.<br>
    [EW22537]
  </p>
</li>

<li>
  <p>
    In EWARM 6.21.4:<br>
    The compiler now avoids widening partial definitions.<br>
    [EW22539]
  </p>
</li>

<li>
  <p>
    In EWARM 6.21.4:<br>
    When the Thumb-1 instruction <code>ADD.N Rdn,Rdn,SP</code> is widened the equivalent Thumb-2
    instruction <code>ADD.W Rdn,SP,Rdn</code> is used, since <code>ADD.W Rdn,Rdn,SP</code> is unpredictable.<br>
    [EW22555]
  </p>
</li>

<li>
  <p>
    In EWARM 6.21.4:<br>
    The compiler no longer places too many constants or string literals between a branch
    and its target, which for a Thumb-1 function where <code>LR</code> is not pushed could result in
    "Internal error: Jump distance to far for B".<br>
    The compiler also no longer places too many constants or string literals between an <code>ADR</code>
    instruction and its target, which could result in "Internal error:[AsmLine - OgAsm]: Error[400]: Expression out of range".<br>
    [EW22611]
  </p>
</li>

<li>
  <p>
    In EWARM 6.21.4:<br>
    The compiler no longer crashes when compiling a reference to <code>ASR</code>, <code>LSR</code>,
    <code>LSL</code>, <code>ROR</code>, or <code>RRX</code>.<br>
    [EW22614]
  </p>
</li>
</ul>

  <h4><A NAME="his620">V6.20 2011-04-29</A></h4>
  <b>New features</b>
  <ul>
       <li><p>
       <code>time.h</code> has an optional 64-bit interface that supports years from -9999 up to 9999.
       For more information see the <A href="../EWARM_DevelopmentGuide.ENU.pdf">Development guide</A>.
       </p></li>

  </ul>
  <b>Program corrections</b>	
  <ul>
 
<li>
  <p>
    When compiling a C file with the <code>--use_c++_inline</code> option, the C99 rule that a public inline
    function definition cannot reference functions or variables with internal linkage is no longer
    checked.<br>
    [EW22161]
  </p>
</li>

<li>
  <p>
    Loops where the final statement in the loop body is a switch will no longer trigger an
    internal error on High optimization.<br>
    [EW22183]
  </p>
</li>

<li>
  <p>
    The C++ C system headers (<code>errno.h</code>, etc) can now be included
    inside an <code>extern "C"</code> block.<br>
    [EW22188]
  </p>
</li>

<li>
  <p>
    A <code>while</code> loop with multiple returns in the loop body will no longer trigger an internal error.<br>
    [EW22195]
  </p>
</li>

<li>
  <p>
    Now the compiler can handle macro parameters that contains multibytes.<br>
    [EW22214]
  </p>
</li>

<li>
  <p>
    Compilation of modules with a very large number of constant data symbols is now considerably faster.<br>
    [EW22243]
  </p>
</li>

<li>
  <p>
    When the <code>offsetof</code> macro is used in a macro argument for a user-defined macro,
    the compiler no longer produces unwanted warnings about the contents of the <code>offsetof</code> macro.<br>
    [EW22250]
  </p>
</li>

<li>
  <p>
    The symbol <code>__vector_table</code> is now included when linking with the file
    <code>arm\src\lib\thumb\cstartup_M.c</code> delivered with the product.<br>
    [EW22252]
  </p>
</li>

<li>
  <p>
    The compiler now correctly handles multibyte characters in a comment and the source line splice mechanism.<br>
    [EW22276]
  </p>
</li>

<li>
  <p>
    The unrolling of a one-trip loop with multiple tests and empty loop body now works also when the
    second test is used to determine that only one iteration of the loop shall be executed.<br>
    [EW22295]
  </p>
</li>

<li>
  <p>
    Complex expressions involving left-shifts and subtractions will always be optimized correctly.<br>
    [EW22306]
  </p>
</li>

<li>
  <p>
    In some cases the compiler could generate a Thumb-2 <code>ADD</code> instruction with negative 8-bit 
    immediate, which the assembler would convert to a narrowThumb-1 <code>SUB</code> instruction.
    This has been corrected.<br>
    [EW22308]
  </p>
</li>

<li>
  <p>
    MISRA C rules were erroneously applied to the constant expression for the address in a 
    <code>#pragma location</code> or after the <code>@</code> operator, resulting in spurious
    diagnostics when MISRA C checking was enabled. This has been corrected.<br>
    [EW22321]
  </p>
</li>

<li>
  <p>
    The compiler no longer produces an internal error when generating code for Thumb-2 and trying to split
    a 64-bit store into two 32-bit stores (for example due to alignment) when the address operand is of
    the form <code>[&lt;Rn&gt;,&lt;Rm&gt;,#&lt;imm&gt;]</code>.<br>
    [EW22324]
  </p>
</li>

<li>
  <p>
    Now the compiler can produce an error for a nonstandard implicit cast of a function to a pointer-to-member.<br>
    [EW22337]
  </p>
</li>

<li>
  <p>
    Trampoline functions <code>__iar_via_rw_&lt;Rn&gt;</code> are now generated as a writable section fragment, so
    that <code>__ramcode</code> functions can be used also in cases were such a function is needed.<br>
    [EW22346]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    The compiler no longer exits with internal error when optimizing conditional jumps.<br>
    [EW22404]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    For cores with media extensions, the compiler no longer generates <code>ADD</code> instead of
    <code>{S,U}XTA{B,H}</code>.<br>
    [EW22407]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    The compiler no longer reports internal error when generating code for Thumb-2 and trying to split
    a 64-bit load into two 32-bit loads (for example due to alignment) when the address operand is of
    the form <code>[&lt;Rn&gt;,&lt;Rm&gt;,#&lt;imm&gt;]</code>.<br>
    [EW22415]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    In static initialization of a structure or an array of structures, fields following an unnamed
    bit-field no longer get incorrect values.<br>
    [EW22416]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    The compiler erroneously issued warning Pe021 (type qualifiers are meaningless in this declaration)
    when using the keyword <code>__packed</code> on a struct or class definition.<br>
    [EW22417]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    Loops with <code>goto</code> statements no longer trigger an internal error for any case.<br>
    [EW22420]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.2:<br>
    The compiler no longer abort with an internal error for aggregate initializers consisting entirely of
    constant integers in some cases involving non-integer, non-aggregate types nested more than two levels
    down in the unspecified parts of the initializer.<br>
    [EW22424]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.3:<br>
    When generating Thumb-2 code, access to 32-bit floating point values on a large stack frame no longer causes internal error.<br>
    [EW22439]
  </p>
</li>

<li>
  <p>
    In EWARM 6.20.3:<br>
    Pointer constants involving a cast from an integer could get an incorrect type, leading to spurious errors or internal errors.
    This has been corrected.<br>
    [EW22441]
  </p>
</li>
  </ul>


  <h4><A NAME="his610">V6.10 2010-11-04</A></h4>
  <b>New features</b>
  <ul>
          <li><p> The product now uses the current C standard defined in 1999, 
               known as C99, as the default C language. The previous major 
               version of the product used the former C standard defined in 
               1989, known as C89. C89 can still be used in the compiler by 
               using the <code>--c89</code> option. The product will not be totally 
               backwards-compatible though, because the support for some C99 
               features has been withdrawn. Variable length arrays, VLAs, in 
               C99, are not supported in the default C language. They can be 
               enabled with the option <code>--vla</code>. The C library  
               supports all C99 functionality, and more, but only if used with 
               the C99 language or with any C++ language. If used with the C89 
               language, C99-added functionality will not be allowed.</p></li>
          <li><p> The implementation of EC++ and EEC++ has not changed in any
               major way.</p></li>
          <li><p> Support for the C++ language 
               has been added. By default, it fully supports the 2003 C++ 
               standard, but can be used with exceptions and/or runtime type 
               information disabled by using <code>--no_exceptions</code> and 
               <code>--no_rtti</code> respectively.</p></li>
          <li><p>Thread-safe libraries<br />
               The DLIB library now supports 
               being used in a threaded environment. Some library systems, like
               the heap and the file structure, will be guarded by locks. Other
               library systems, like <code>locale</code> and <code>errno</code>, will have their
               static data allocated in thread-local storage. The DLIB thread
               support can either be supported by your chosen RTOS or can be
               manually implemented. 
               For more information see the <A href="../EWARM_DevelopmentGuide.ENU.pdf">Development guide</A>.
          </p></li>
          <li><p> The compiler and assembler now automatically know where the 
               library's system headers reside. You can control the compiler
               using the options: 
               <ul>
                 <li><code>--dlib_config</code>, to choose a configuration in the 
                     DLIB library.</li>
                 <li><code>--system_include_dir</code>, to override the directory
                     to use as system header base.</li>
                 <li><code>--no_system_include</code>, to turn the automation off.
                     </li>
               </ul></p></li>
          <li><p> The compiler can now optimize some floating-point expressions more agressively
               by using the option <code>--relaxed_fp</code>. If enabled, the
               compiler tries to reduce the floating-point type used in 
               floating-point expressions. This can cause a small loss of accuracy.
          </p></li>
  </ul>
  <b>Program corrections</b>
  <ul>
<li>
  <p>
    The library function <code>fpclassify()</code> handles normal and subnormal numbers correctly.<br>
    [EW21098]
  </p>
</li>

<li>
  <p>
    Small <code>memcpy</code> calls are no longer transformed to assignments unless both the source and
    destination addresses have correct alignment.<br>
    [EW21193]
  </p>
</li>

<li>
  <p>
    The compiler now checks that different kinds of variables are no placed in the same section.<br>
    [EW21351]
  </p>
</li>

<li>
  <p>
    An internal error should no longer occur if <code>__segment_begin()</code> or
    <code>__segment_end()</code> is used in conditional code.<br>
    [EW21770, EW21838, EW21905]
  </p>
</li>

<li>
  <p>
    Loops that decremented an unsigned loop counter past zero could in some cases be
    incorrectly optimized.<br>
    [EW21795]
  </p>
</li>

<li>
  <p>
    Now all system headers do not generate MISRA errors.<br>
    [EW21799]
  </p>
</li>

<li>
  <p>
    When optimizing, the the compiler now handles an initializer containing a function pointer with an offset.<br>
    [EW21870]
  </p>
</li>

<li>
  <p>
    The endian attribute is not supported for pointers or arrays. Now an endian attribute can
    no longer be specified for pointers or arrays.<br>
    [EW21887]
  </p>
</li>

<li>
  <p>
    Reversal of byte order is now correctly performed also for combinations of endian
    attributes and unaligned accesses. Previously, this was in some cases not handled.<br>
    [EW21888]
  </p>
</li>

<li>
  <p>
    At optimization level High, speed-optimizing small loops similar to
    <pre><code>
      int test(int n)
      {
        while (n-- > 0)
          if (!foo(n))
            break;
        return n;
      }
      </code></pre>
    could in some cases be incorrectly unrolled and cause an internal error.<br>
    [EW21949]
  </p>
</li>

<li>
  <p>
    A class with a member that is a nameless struct, or an array of nameless structs,
    where at least one of the members is not a PoD, could cause
    an internal error while compiling.<br>
    [EW21958]
  </p>
</li>

<li>
  <p>
    A while loop with a preincrement or predecrement in the loop test could be incorrectly optimized
    if the final part of the loop body was a do loop.<br>
    [EW21999]
  </p>
</li>

<li>
  <p>
    The compiler will no longer merge instruction sequences (through cross call or
    cross jump optimizations) that are not equal, due to the register operand of a
    Thumb-2 compare-and-branch instruction (<code>CBZ</code> or <code>CBNZ</code>).<br>
    [EW22000]
  </p>
</li>

<li>
  <p>
    When an <code>enum</code> is specified as a parameter or return type before it has been defined,
    the compiler will no longer record the wrong num size (attribute <code>Tag_ABI_enum_size</code>)
    in the ELF file.<br>
    [EW22013]
  </p>
</li>

<li>
  <p>
    In Thumb-2, the compiler no longer issues an internal error in an attempt to widen
    <code>MULS.N</code> to <code>MULS.W</code> (which is not a Thumb-2 instruction)
    to achieve a 4-byte alignment of a following instruction or label.<br>
    [EW22018]
  </p>
</li>

<li>
  <p>
    The compiler can now handle a function symbol as an argument to compiler optimized functions
    like <code>memcpy</code>.<br>
    [EW22052]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    Nested <code>for</code> loops where the inner loop's initial or final value was the outer
    loop's variable, multiplied with a constant scaling factor or with a constant offset, no
    longer causes an internal error on high optimization.<br>
    [EW22078]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    Some <code>while</code> loops with multiple exits no longer causes an internal error on
    high optimization.<br>
    [EW22080]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    Constant data is now placed in the <code>.rodata</code> section if the compiler has not
    generated a direct <code>ADR</code> reference. If there is an <code>ADR</code> reference,
    the constant data is placed in the <code>.text</code> section.<br>
    [EW22081]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    Standard C++ is now enabled also for the kickstart products.<br>
    [EW22089]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    Now the MISRA-C:2004 rule 20.2 checker can handle a long preprocessor symbol define.<br>
    [EW22117]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    For Cortex-M3, the compiler no longer attempts to generate a sub-routine for identical
    instruction sequences (cross-call) that end with a call to a software interrupt function
    (<code>SWI</code>), which would result in an internal error.<br>
    [EW22118]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    The compiler no longer removes code that uses the result of an <code>STREX</code>
    instruction (the instruction can be generated by using the <code>__STREX</code> intrinsic
    function).<br>
    [EW22119]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    The compiler no longer uses a signed 16-bit value as the immediate operand for the
    <code>MOVT</code> instruction. A 16-bit unsigned value is used instead, because
    <code>MOVT</code> expects an immediate value between 0 and 65535.<br>
    [EW22121]
  </p>
</li>

<li>
  <p>
    In EWARM 6.10.2:<br>
    Evaluating a function address without using the result no longer causes an internal error.<br>
    [EW22146]
  </p>
</li>
  </ul>

  <h4><A NAME="his550">V5.50 2010-04-21</A></h4>
  <b>New features</b>  
  <ul>
      <li>
        <p>
        The following C library floating-point functions, for devices without VFP, have been optimized for speed and size:<br>
        <code>sqrt</code>, <code>sqrtf</code>, <code>modf</code>, <code>modff</code>, <code>fabs</code>,
        <code>fabsf</code>, <code>fmod</code>, <code>fmodf</code>, <code>floor</code>, <code>floorf</code>,
        <code>ceil</code>, <code>ceilf</code>, <code>ldexp</code>, <code>ldexpf</code>, <code>frexp</code>,
        <code>frexpf</code>.
        </p>
      </li>
      <li>
        <p>
        The following C library floating-point functions, for devices with VFP, have been optimized for speed and size:<br>
        <code>sqrt</code>, <code>sqrtf</code>,
        <code>modf</code>, <code>modff</code>, <code>fabs</code>,
        <code>fabsf</code>, <code>fmod</code>, <code>fmodf</code>, <code>floor</code>, <code>floorf</code>,
        <code>ceil</code>, <code>ceilf</code>, <code>ldexp</code>, <code>ldexpf</code>, <code>frexp</code>,
        <code>frexpf</code>, <code>asin</code>, <code>asinf</code>,
        <code>acos</code>, <code>acosf</code>, <code>atan</code>, <code>atanf</code>, <code>atan2</code>, <code>atan2f</code>.
        </p>
      </li>
  </ul>
  <b>Program corrections</b>
  <ul>
        <li>
          <p>
            While optimizing a function that contained code that prevented the end of the function to be reached,
            the compiler would erroneously leave a label after the last reachable instruction. This label was later
            interpreted as a leak of flow-of-control out of the function and an internal error was generated.<br>
            [EW21541]
          </p>
        </li>

        <li>
          <p>
            A call to the map index operator now default-constructs the value if the key is not found even for base types.<br>
            [EW21592]
          </p>
        </li>

        <li>
          <p>
            Using designated initializers (a C99 feature available in EC++ when IAR extensions are enabled) with a
            static storage duration object that needed C++ dynamic initialization could cause incorrect initialization.<br>
            [EW21649]
          </p>
        </li>

        <li>
          <p>
            The use of intrinsics for <code>LDC</code> and <code>STC</code> could in some cases crash the compiler (access violation).<br>
            [EW21657]
          </p>
        </li>

        <li>
          <p>
            A function, <code>f</code>, updating a global variable, could be incorrectly optimized, if<br>
            <ul>
            <li><code>f</code> had multiple return statements,</li>
            <li>at least one of the return statements was inside a loop, and</li>
            <li><code>f</code> was inlined in another function.</li>
            </ul>
            [EW21666]
          </p>
        </li>

        <li>
          <p>
            For a function call where the compiler inserts a call to <code>memcpy</code> to construct a stack parameter,
            the register <code>R1</code> is no longer assumed to survive the call to <code>memcpy</code>.<br>
            [EW21668]
          </p>
        </li>

        <li>
          <p>
            The compiler no longer generates unaligned memory accesses for Cortex-M0.<br>
            [EW21687]
          </p>
        </li>

        <li>
          <p>
            The compiler no longer generates branch instructions without size specifiers (<code>.W</code> or <code>.N</code>)
            for Thumb-2 capable cores (in Thumb mode), because doing so sometimes could result in an
            internal error.<br>
            [EW21699]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            Using an enumerator constant directly as a floating-point value no longer
            produces a corrupt value.<br>
            [EW21704]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            Array pointer decay of a block local static array with template parameter
            dependent size no longer results in an internal error.<br>
            Example:<br>
            <pre>
              template<typename C> struct Q
              {
                C * get()
                {
                  static long x[sizeof(C)];
                  return (C *)x;
                }
              };</pre>
            [EW21728]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            The instruction scheduling for ARM11 no longer issues an internal error
            when scheduling a <code>PKHBT</code> instruction with a shifted operand.<br>
            [EW21745]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            The <code>USAT</code> instruction (for unsigned saturation) is now generated with
            correct bitwidth also in Thumb-2 mode (was off by one).<br>
            [EW21768]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            Cast from <code>double</code> to <code>long long</code> no longer generates faulty values for very
            large inputs with a non-zero fractional part. Values in the range
            [2^32, 2^52] were affected.<br>
            [EW21786]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            An internal error no longer occurs for conditions where the test is a
            <code>? :</code> expression on the form:<br>
            <code>if ((condition1 && condition2) ? 1 : 0)</code><br>
            [EW21807]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            Range checks for the address of a function parameter is now translated
            correctly: it could earlier in some cases result in internal error.<br>
            [EW21826]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.5:<br>
            The compiler is now able to inline a function that in its body calls a
            function with the <code>__noreturn</code> attribute.<br>
            [EW21841]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.7:<br>
            An internal error is no longer issued when multiple constant-table
            references are placed in the same IT-block for a function that is so large that
            an <code>LDR (immediate)</code> instruction cannot reach outside the function.<br>
            [EW21968]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.7:<br>
            Loops that contain conditional accesses through an invariant pointer variable
            are no longer incorrectly optimized.<br>
            [EW21992]
          </p>
        </li>

        <li>
          <p>
            In EWARM 5.50.7:<br>
            A signed division of an expression with a negative divider no longer gets optimized
            into using an unsigned division.<br>
            [EW22043]
          </p>
        </li>
  </ul>

  <h4><A NAME="his541">V5.41 2009-12-14</A></h4>
  <b>New features</b>    
  <ul>
    <li>
      None.
    </li>
  </ul>
  <b>Program corrections</b>
  <ul>
<li>
  <p>
    <code>cstartup_M.c</code> now includes default interrupt handlers.<br>
    [EW21314]
  </p>
</li>

<li>
  <p>
    Expressions on the form<br>
    <code>if (expr < 0) v = -expr;</code><br>
    are no longer optimized incorrectly.<br>
    [EW21340]
  </p>
</li>

<li>
  <p>
    A test inside a loop is no longer optimized incorrectly if<br>
    a) the loop had constant values for the initial and the final iteration,<br>
    b) the test compared an expression to a constant, and<br>
    c) the calculation of the expression would overflow or underflow for either the initial or final iteration.<br>
    [EW21363]
  </p>
</li>

<li>
  <p>
    Complex |-expressions no longer cause infinite loops during optimization.<br>
    [EW21380]
  </p>
</li>

<li>
  <p>
    Registers might be spilled to the stack frame when there are more live variables than registers.
    A spilled large register parameter (more than 8 bytes) no longer results in an internal error.<br>
    [EW21386]
  </p>
</li>

<li>
  <p>
    The linker is now more relaxed concerning attribute checking when linking with explicitly specified libraries.<br>
    [EW21387]
  </p>
</li>

<li>
  <p>
    Absolute addressed variable accesses no longer loose the <code>volatile</code> attribute during optimization.<br>
    [EW21400]
  </p>
</li>

<li>
  <p>
    Debug information for classes inheriting from a base class whose primary base was inherited virtually
    is no longer generated incorrectly. The old problem could result in incorrect display of base classes in C-SPY.<br>
    [EW21411]
  </p>
</li>

<li>
  <p>
    An error from the assembler in inline assembler code is no longer reported as a compiler internal error.<br>
    [EW21436]
  </p>
</li>

<li>
  <p>
    The compiler now encodes the character value 255 in a string literal using an escape sequence, to work
    around the fact that the assembler interprets such a value as end of file.<br>
    [EW21443]
  </p>
</li>

<li>
  <p>
    Registers are no longer renamed in situations where unused registers become used after
    renaming, to avoid situations where such registers would not be saved on the stack.<br>
    [EW21449]
  </p>
</li>

<li>
  <p>
    The compiler now generates correct code instead of reporting an internal error in situations where an entry in a constant
    table is duplicated so that it can be reached by all its references.<br>
    [EW21471]
  </p>
</li>

<li>
  <p>
    In EWARM 5.41.2:<br>
    Integral expressions in loops are no longer optimized incorrectly when the expression adds or subtracts
    a constant to/from a variable <code>(x + ... + C)</code>, and the variable is assigned the same constant
    subtracted/added from/to the loop index variable  <code>(x = i - C)</code>.<br>
    [EW21493]
  </p>
</li>


<li>
  <p>
    In EWARM 5.41.2:<br>
    Two tests on the form<br>
    <code>expr1 > c1 && expr2 < c2</code><br>
    or<br>
    <code>expr1 < c1 || expr2 > c2</code><br>
    are no longer incorrectly optimized as a range test when <code>expr1</code> is not
    identical to <code>expr2</code>.<br>
    [EW21498]
  </p>
</li>


<li>
  <p>
    In EWARM 5.41.2:<br>
    A bitwise and operation between a constant and a value loaded from memory will sometimes be transformed
    into a truncated load, which loads only a part of the variable from memory. For a 64-bit variable
    (in other words, <code>long long</code>) the truncated load will no longer result in an internal error.<br>
    [EW21517]
  </p>
</li>


<li>
  <p>
    In EWARM 5.41.2:<br>
    Complex array index expressions in loops no longer result in an internal error.<br>
    [EW21545]
  </p>
</li>


<li>
  <p>
    In EWARM 5.41.2:<br>
    Types smaller that 32 bits must sometimes be sign- or zero-extended before being compared
    (using for example <code>CMP</code>, <code>TST</code>, or <code>TEQ</code>). Sign- and zero-extends
    are now generated when needed also for cases when the result of bitwise and/xor operations
    are compared with zero (in other words, cases for which a <code>TST</code> or <code>TEQ</code> instruction
    is generated).<br>
    [EW21550]
  </p>
</li>


<li>
  <p>
    In EWARM 5.41.2:<br>
    Correct values are now produced when the intrinsics <code>__CLZ</code>, <code>__REV</code>, or
    <code>__REVSH</code> are used with a constant argument.<br>
    [EW21561]
  </p>
</li>
  </ul>

    <h4><A NAME="his540">V5.40 2009-07-10</A></h4>
  <b>New features</b>  	
  <ul>
    <li>
      None.
    </li>
  </ul>
  <b>Program corrections</b>  
  <ul>

<li>
  <p>
    An if-then-else statement could be optimized into a question mark expression even at low optimization levels, which would make the debugger confused as to which is the current statement. The optimization has now been disabled at optimization levels 'low' and 'none'.<br>
    [EW20828]
  </p>
</li>

<li>
  <p>
    The compiler no longer generates a message for the usage of <code>long long</code> in system headers even
    though the options <code>--strict_ansi</code> and <code>--warnings_are_errors</code> are used.<br>
    [EW20844]
  </p>
</li>

<li>
  <p>
    The final value of variables in loops transformed into a <code>memcpy</code> or <code>memset</code> call could,
    in some cases, be off by one.<br>
    [EW20886]
  </p>
</li>

<li>
  <p>
    Fixed an internal error in the compiler when trying to match an out-of-line template member function definition to the correct declaration. The problem occurred when two or more template member functions differed in the this qualifiers of a pointer to member function type parameter.<br>
    Example:<br><code><pre>
      struct X
      {
        template<typename Y, typename Z> int fun(Y (Z::*fp)());
        template<typename Y, typename Z> int fun(Y (Z::*fp)() const);
      };

      template<typename Y, typename Z>
      int X::fun(Y (Z::*fp)())
      {
        return 1;
      }</pre></code>
    [EW20920]
  </p>
</li>

<li>
  <p>
    The MISRA C error <code>Pm020</code> was incorrectly reported as a warning and the corresponding rule number was omitted from the error message.<br>
    [EW20925]
  </p>
</li>

<li>
  <p>
    When compiling multiple input files (<code>--mfc</code>) in Embedded C++ mode, the compiler could get an
    internal error <code>[assertion failed at: ".\src\parser\edg\lower_il.c", line 2484]</code> in some circumstances.<br>
    [EW20927]
  </p>
</li>

<li>
  <p>
    Loops where a global variable (<code>g</code>) just held a result (<code>g</code> passed no value
    between loop iterations) could in some cases be incorrectly optimized.
    <pre>
    for (...) {
       g = ...
       if (...) break;
       g = ...
    }</pre>
    [EW20952]
  </p>
</li>

<li>
  <p>
    The compiler and assembler produced object files where group section header table entries did not appear before the entries of all their members, as required by the ELF format.<br>
    [EW20988]
  </p>
</li>

<li>
  <p>
    After a <code>memcpy</code> call, where a buffer (<code>b</code>) was assigned <code>n</code> characters from a string
    literal of length <code>n</code> (all characters except the zero termination), a <code>b[n] = 0</code> assignment
    could erroneously be removed.<br>
    [EW20991]
  </p>
</li>

<li>
  <p>
    Associative expressions containing both a division and a modulo operation could in some rare cases be
    incorrectly optimized.<br>
    [EW21010]
  </p>
</li>

<li>
  <p>
    When compiling EEC++ for Thumb, a class that inherits from three or more classes where a virtual method has three or more arguments, one of the generated thunks was faulty (when compiling with multiple inheritance there is sometimes a need for a piece of code that adjusts the 'this' pointer. This piece of code is known as a 'thunk').<br>
    [EW21014]
  </p>
</li>

<li>
  <p>
    For a struct <code>x</code> of 8 bytes or more, allocated as a register variable with two fields <code>a</code>
    and <code>b</code>, a simple if statement that can be reduced to a question mark expression (such as
    <code>x.a < x.b ? x.a : x.b</code>) could result in an internal error.<br>
    [EW21017, 21108]
  </p>
</li>

<li>
  <p>
    Member accesses to auto structs assigned with <code>memcpy</code> could in some cases be incorrectly optimized.<br>
    [EW21020]
  </p>
</li>

<li>
  <p>
    When compiling for VFP, a function call with a variable argument list where an argument passed on the
    stack is converted from <code>double</code> to <code>int</code> could result in an incorrect stack pointer value.<br>
    [EW21023]
  </p>
</li>

<li>
  <p>
    When compiling with <code>--legacy RVCT3.0</code> for Thumb mode, and a constant is shared between functions of the same compilation unit, the compiler could in some cases generate one of the functions in a segment part with two bytes alignment. Four bytes alignment is required in such cases to correctly resolve the <code>R_ARM_THM_PC8</code> relocation.<br>
    [EW21031]
  </p>
</li>

<li>
  <p>
    The code generator could fail to detect that an object had been placed with stricter alignment than required by the type. This would, in turn, cause the compiler to crash when the code generator at a later stage expected the higher alignment.<br>
    [EW21059]
  </p>
</li>

<li>
  <p>
    When a switch statement inside a loop is generated as a table with negative offsets, the same register could be reused for two different purposes at table lookup.<br>
    [EW21100]
  </p>
</li>

<li>
  <p>
    The compiler could terminate with an internal error in some cases involving enum types defined in a template class.<br>
    [EW21101, 21112]
  </p>
</li>

<li>
  <p>
    When optimizing loops where the loop limit is the result of an expression involving possibly negative values in a bitwise AND operation, the compiler could in some cases erroneously conclude that the loop body would execute at least once and eliminate the test of the initial iterator value against the limit. The result of this is incorrect loop code for the case when the loop body should not be executed at all.<br>
    [EW21118,21120]
  </p>
</li>

<li>
  <p>
    In EWARM 5.40.4:<br>
    The runtime library no longer assumes that unaligned access is supported in Cortex-M0 or Cortex-M1.<br>
    [EW21262]
  </p>
</li>
<li>
  <p>
    In EWARM 5.40.4:<br>
    Scalar stack parameters smaller than 32-bit are now properly sign- or zero extended before the
    function is called.<br>
    [EW21271]
  </p>
</li>
<li>
  <p>
    In EWARM 5.40.4:<br>
    Compilation of a file using either of the intrinsics <code>__get_interrupt_state</code> or
    <code>__set_interrupt_state</code> no longer results in an internal error.<br>
    [EW21272]
  </p>
</li>
<li>
  <p>
    In EWARM 5.40.4:<br>
    MISRA C is now available in EWARM-CM.<br>
    [EW21324]
  </p>
</li>
<li>
  <p>
    In EWARM 5.40.4:<br>
    The compiler now generates correct debug information for calls to C++ member functions defined
    in another module. The <b>step into</b> debugger command for such a call now works properly.<br>
    [EW21327]
  </p>
</li>
  </ul>

    <h4><A NAME="his530">V5.30 2009-01-23</A></h4>
    <b>New features</b>  	
    <ul>
      <li><b>__task extended keyword</b><br>
      By default, functions save the contents of used preserved registers on the stack upon
      entry, and restore them at exit. Functions that are declared<code> __task </code>do not save all
      registers, and therefore require less stack space. This is typically used by realtime operating systems.
      </li>
	</ul>
    <b>Program corrections</b>
	<ul>

      <li>
        <p>
          Creating a variable with a class/struct/union type with type errors in one
          or more of its fields could earlier result in an internal error. This has been corrected.<br>
          [EW20367]
        </p>
      </li>

      <li>
        <p>
          In some unusual cases the compiler could terminate ungracefully. Ungraceful
          terminations are now prevented.<br>
          [EW20380]
        </p>
      </li>

      <li>
        <p>
          Stack usage reported in the listfile is now again a safe approximation.<br>
          [EW20410]
        </p>
      </li>

      <li>
        <p>
          In some cases two pre/post increment/decrements in two consecutive
          expressions could cause an internal error. This problem has been corrected.<br>
          [EW20419]
        </p>
      </li>

      <li>
        <p>
          Irregular loops could in some rare cases be optimized incorrectly. This problem has been corrected.<br>
          [EW20428]
        </p>
      </li>

      <li>
        <p>
          Specifying a designated initializer on a field inside more than one level
          of anonymous unions/structs could earlier cause an internal error in the compiler.
          This problem has been corrected.<br>
          [EW20439]
        </p>
      </li>

      <li>
        <p>
          An inline-assembler operation can now correctly generate an error for absolute addressing in ELF.<br>
          [EW20489]
        </p>
      </li>

      <li>
        <p>
          The compiler could fail when generating code for certain loop constructs. This has been corrected.<br>
          [EW20503]
        </p>
      </li>

      <li>
        <p>
          In some cases an address expression inside two nested loops could use a
          variable before it had been assigned a value. This has been corrected.<br>
          [EW20531]
        </p>
      </li>

      <li>
        <p>
          At medium optimization level (or higher) for Cortex-M3, compilation of certain combinations of the constant 256
          and the question mark operator (<code>a?b:c</code>) could earlier result in an internal error with the message
          "illegal state". This has been corrected.<br>
          [EW20537]
        </p>
      </li>

      <li>
        <p>
          Variables of small type (for example <code>char</code>) could earlier be incorrectly hoisted
          as a loop counter even though it might wrap. This has been corrected.<br>
          [EW20563]
        </p>
      </li>

      <li>
        <p>
          A<code> do </code>loop copying consecutive shorts, integers, or long longs have now a
          correct byte count when translated into a memcpy call.<br>
          [EW20570]
        </p>
      </li>

      <li>
        <p>
          Return value temporaries created for functions that use a return value
          pointer did not get marked as having had their address taken. This has been corrected.<br>
          [EW20572]
        </p>
      </li>

      <li>
        <p>
          In some cases the code could be optimized incorrectly if pointers of different types were
          used to access the same memory address. This has been corrected.<br>
          [EW20581]
        </p>
      </li>

      <li>
        <p>
          Certain operations (typically bit-wise) involving template static data members of integer type
          could cause an internal error when compiling template code. This has been corrected.<br>
          [EW20608]
        </p>
      </li>

      <li>
        <p>
          A loop could in some cases be incorrectly optimized if it updated a global
          variable preceded by an indirect store of the same type as the global
          variable.<br>
          [EW20627]
        </p>
      </li>

      <li>
        <p>
          The compiler no longer tries to put <code>CPSIE/CPSID</code> in an IT-block.<br>
          [EW20652]
        </p>
      </li>

      <li>
        <p>
          The min and max templates should now be optimized correctly after function inlining.<br>
          [EW20654]
        </p>

      <li>
        <p>
          The compiler no longer crashes after issuing the error Pe020.<br>
          [EW20684]
        </p>

      <li>
        <p>
          The intrinsic function __set_CPSR() generated the wrong assembler instruction.
          This has been corrected.<br>
          [EWARM-268]
        </p>

      </li>

    </ul>

    <h4><A NAME="his520">V5.20 2008-06-24</A></h4>
    <b>New features</b>  
    <ul>
      <li>
        <p>
	  Support for vector floating point (VFP) coprocessors.
	</p>
      </li>
	  </ul>
      <b>Program corrections</b>
	  <ul>
      <li>
        <p>
          The compiler no longer removes reads from uninitialized volatile auto variables
          from the code.<br>
          [EW19167]
        </p>
      </li>
      <li>
        <p>
          A thunk with fall through is now padded properly whenever it is needed.<br>
          [EW19481]
        </p>
      </li>
      <li>
        <p>
          Source lines after a<code> #line </code>directive are now included in compiler list files.<br>
          [EW19654]
        </p>
      </li>
      <li>
        <p>
          The compiler can now handle segment/section names that are the same as assembler
          instruction names, register names, etc.<br>
          [EW19674]
        </p>
      </li>
      <li>
        <p>
          Out-of-line definitions of member functions of a template class are now made properly
          tentative.<br>
          [EW19678]
        </p>
      </li>
      <li>
        <p>
          Declaring a class-specific two-operand operator<code> delete </code>in a class template no longer causes
          the compiler to crash.<br>
          [EW19707]
        </p>
      </li>
      <li>
        <p>
          The compiler no longer crashes after emitting an error indicating an extraneous
          <code> typename </code>keyword in a template.<br>
          [EW19796]
        </p>
      </li>
      <li>
        <p>
          MISRA C rule 23 no longer gives an error for non code symbols.<br>
          [EW19802]
        </p>
      </li>
      <li>
        <p>
          Realloc no longer leaves the heap in a broken state after a call that tries to allocate
          more memory than there is in the heap.<br>
          [EW19803]
        </p>
      </li>
      <li>
        <p>
          The compiler no longer crashes when generating DWARF debug information for a class-external
          <code> typedef </code>of a class-scoped<code> enum </code>type with more than 9 constants.<br>
          [EW19820]
        </p>
      </li>
      <li>
        <p>
          When performing<code> memcpy </code>in Cortex-M3 and the source and destination pointers have different
          alignments, the last 16 bytes are now copied also in cases where the size is:<br>
          <code>
          size = 32 + ((4 -(DstPtr & 3)) & 3) + (y * 16);       // y = 0, 1, 2 e.t.c.<br>
          </code>
          [EW19837]
        </p>
      </li>
      <li>
        <p>
          Instruction scheduling will no longer lift pop of LR over a function/library call.<br>
          [EW19872]
        </p>
      </li>
      <li>
        <p>
          A call to<code> memmove </code>with aligned parameters is no longer incorrectly transformed into
          <code> __aeabi_memcpy4 </code>instead of<code> __aeabi_memmove4</code>.<br>
          [EW19878]
        </p>
      </li>
      <li>
        <p>
          Masking a<code> long long </code>value now works.<br>
          [EW19908]
        </p>
      </li>
      <li>
        <p>
          A function call, where one parameter is a pointer to a signed integral type that is
          cast to a pointer to the unsigned type of the same size (or vice versa), no longer causes an
          internal error if the function call is inlined.<br>
          [EW19933]
        </p>
      </li>
      <li>
        <p>
          Loops with an unsigned loop variable, going from 0 to 1, will no longer be optimized
          incorrectly.<br>
          [EW19973]
        </p>
      </li>
      <li>
        <p>
          Constant tables layout generation for Thumb2 code has been adjusted.<br>
          [EW19984]
        </p>
      </li>
      <li>
        <p>
          In some rare cases structure assignments, where the source was a indirection of a pre- or
          post-incremented pointer, could be optimized incorrectly. This has been corrected.<br>
          [EW20071]
        </p>
      </li>
      <li>
        <p>
          Debug information for variables in high registers (<code>r8-r14</code>) in Thumb2 code has
          been improved.<br>
          [EW20098]<br>
          [EW20100]
        </p>
      </li>
      <li>
        <p>
          Clustering now handles segment/section-located initialized variables.<br>
          [EW20149]
        </p>
      </li>
      <li>
        <p>
          In some rare cases an optimization that temporarily hoisted a memory cell (i.e. a global
          variable or a structure member) to a register did not transform the code correctly and
          one or more uses could still refer to the memory cell. This has been corrected.<br>
          [EW20150]
        </p>
      </li>
      <li>
        <p>
          Fall through from an arm function to a thumb function is no longer generated.<br>
          [EW20164]
        </p>
      </li>
      <li>
        <p>
          Invalid instructions no longer generate internal errors.<br>
          [EW20199]
        </p>
      </li>
      <li>
        <p>
          <code>Tag_ABI_enum_size </code>now reflects the real size of<code> enum </code>used.<br>
          [EW20203]
        </p>
      </li>
    </ul>

    <h4><A NAME="his511">V5.11 2007-12-11</A></h4>
    <b>New features</b>  
    <ul>
      <li>
	  Support for Cortex-M1 and Cortex-M3.
      </li>
     </ul>
     <b>Program corrections</b>
	 <ul>
      <li>
        <p>
          If the code generator failed to place a small object of aggregate type in registers, 
          it could fail also when it tried to place the object on the stack instead. This happened if the 
          alignment of the object did not match the size of the aggregate members, resulting in 
          the wrong offsets being used for all members except those placed on alignment boundaries.<br>
          [EW19478]
        </p>
      </li>
      <li>
        <p>
          A 32-bit mask operation with all except the highest bit together with a test on 
          the highest bit of the same variable could generate incorrect code in Thumb mode.<br>
          [EW19480]
        </p>
      </li>
      <li>
        <p>
          The section ".textrw" can now be renamed.<br>
          [EW19672]
        </p>
      </li>
      <li>
        <p>
          The compiler can now handle segments/sections with names that are identical
          to names of assembler instructions, registers, etc.<br>
          [EW19674]
        </p>
      </li>
      <li>
        <p>
          Out-of-line definitions of member functions of a template class were not made properly tentative, resulting in erroneous
          'duplicate definition' errors when linking. This has been corrected.<br>
          [EW19678]
        </p>
      </li>
      <li>
        <p>
          Declaring a class-specific two-operand operator delete in a class
          template no longer causes the compiler to crash.<br>
          [EW19707]
        </p>
      </li>
      <li>
        <p>
          Bad syntax in function declarations no longer generate internal errors.<br>
          [EW19718]
        </p>
      </li>
      <li>
        <p>
          Doubles are now rounded correctly.<br>
          [EW20026]
        </p>
      </li>
    </ul>

    <h4><A NAME="his510">V5.10 2007-06-12</A></h4>
    <b>New features</b>  
    <ul>
      <li>
        Object files are now produced in the ELF/DWARF format.
      <li>
	      Support for AEABI, which means interperability with other ARM EABI compliant tools.
      </li>
	 </ul>
     <b>Program corrections</b>
	 <ul>
      <li>
    	  The compiler now produces an error when an initializer for a static variable 
	      contains the address of a bitfield member.<br>  
	      [EW17962]
      <li>
    	  A function-like macro, named as a predefined IAR attribute name, no longer 
	      makes the compiler end erroneously.<br>
	      [EW18386]
      <li>
    	  In rare cases, only the high part of a 64-bit variable was loaded.<br>
	      [EW18735] 
      <li>
    	  NOP instructions, inserted with the intrinsic function <code>__no_operation()</code> was 
        scheduled causing them not to appear at the desired places in the code.<br>
	      [EW18767] 
      <li>
        The header file <code>MtxWrapper.h</code> now works from C++.<br>
        [EW18769]
      <li>
    	  Loops containing array accesses with index expressions of<code> char </code>type could earlier in some 
	      cases be optimized incorrectly.<br>
	      [EW18815,EW18963]
      <li>
    	  Inconsistencies between several declarations or between declaration and definition 
	      of the same function now give proper diagnostics.<br>
	      [EW18818]
      <li>
    	  The header file <code>Dlib_Product.h</code> is now compilable with MISRA C.<br>
	      [EW18843]
      <li>
    	  Interweaved stores with zero and reads from the same structure could earlier be done in 
        incorrect order.<br>
	      [EW18845]
      <li>
	      Wrong code was generated when passing an unaligned struct as parameter in big endian mode.<br>
	      [EW18900]
      <li>
	      <code>swprintf</code> and <code>vswprintf</code> now correctly handle the ending <code>\0</code>.<br>
	      [EW18948]
      <li>
	      In some rare cases, common subexpressions involving a struct pointer (<code>p-&gt;x</code>) 
        was incorrectly optimized if the expression was preceded by an equality test between 
        an other member in the same structure and a constant (<code>p-&gt;y == 0</code>).<br>
	      [EW19015]
      <li>
        Functions with <code>__irq</code> and <code>__fiq</code> now save the vfp status register when compiling for 
        vfp.<br>
        [EW19047]
      <li>
        The compiler no longer generates an erroneous constant for a compound literal that is
        used in a file-scoped initialization.<br>
        [EW19076]
      <li>
        <code>swprintf</code> now handles large strings correctly.<br>
        [EW19105]
      <li>
        Large functions could give the following internal error:
        <code>Internal Error: [CoreUtil/General]: Jump distance to far for B</code>.<br>
        [EW19179]
      <li>
        Clustering could cause zero initialized data to occupy ROM space,
        instead of using zero initialization.<br>
        [EW19232]
      <li>
        The<code> ! </code>operator on a byte in a <code>char</code> buffer (example:<code> return !buf[0];</code>) could earlier cause the internal error:<br>
        <code>Const_Folding - Internal error Unequal types for operator != <br>
        Internal Error: [CoreUtil/General]: Const_Folding - Internal error</code><br>
        [EW19337]
    </ul>

    <h4><A NAME="his441A">V4.41A 2006-12-08</A></h4>
    <b>Program corrections</b>	
      <ul>
        <li>
            The compiler generated misleading errors for unevaluated parts of constant
            expressions in some circumstances, for example:<br>
            <code>const unsigned int z1d = ( (0) ? ( ( 1 >= (1ul << -6) ) ? 1 : 2 ): 1 );</code><br>
            This expression contains a negative shift count, which would normally result
            in a diagnostic, but the problem is in the non-evaluated part of the containing
            conditional expression, so this diagnostic is suppressed.
            The negative shift count makes the comparison undeterminate, which resulted
            in a "constant value is not known" diagnostic. This subsequent diagnostics
            was not suppressed, which it also should have been.<br>
            [EW18140]
        <li>
            In Thumb-mode a tail-call could incorrectly be optimized to jump even when the jump
            distance was just out of reach.<br>
            [EW18151]
        <li>
            A stack-backtrace information problem with <code>__irq</code> and <code>__fiq</code> functions has
            been corrected.<br>
            [EW18152]
        <li>
            Inverting a <code>long long</code> variable could earlier generate an internal error.<br>
            [EW18157]
         <li>         
            Instruction scheduling could earlier incorrectly lose some debug information for inlined functions.<br>
            [EW18180]
         <li>
            A function containing a structure assignment inlined in a loop body could in some 
            rare cases cause an internal error.<br>
            [EW18182]
         <li> 
            The optimizer could incorrectly remove <code>CMP</code> instructions if the 
            preceding arguments looked like constants.<br>
            [EW18231]
         <li>
            When a constant table was placed immediately after a switch table, 
            a dangling (duplicate) label might be left which caused the backtrace 
            analysis to abort the compilation with the following error message
<pre>   Internal error: [CoreUtil/General]: BtThreadAnalyzer:
   No direct arc from node to successor 
</pre>
            [EW18259]
          <li>
            If the compiler found several stores with zero to consecutive memory locations 
            the last store could be done with wrong size.<br>
            [EW18273]
          <li>
            The compiler did not handle large functions properly in thumb mode.<br>
            [EW18276]
          <li>
            The <code>&ltvector&gt</code> header no longer relies on the undefined symbol TRUE<br>
            [EW18284]
          <li>
            Branch chaining optimization could incorrectly chain a <code>BNE</code> 
            instruction via a <code>BHI</code> instruction.</br>
	    [EW18312]
          <li>
             Variables declared both <code>static</code> and <code>volatile</code> were incorrectly not treated as such at all times.<br>
            [EW18316]
          <li>
              For a <b><code>struct</code></b> with <b><code>short</code></b> members, the members
	            could incorrectly be written as a 32-bit entity when the <b><code>short</code></b> member was
	            kept in register. This could also lead to adjacent members being overwritten.<br>
	            [EW18320]
          <li>
             In some rare cases the intrinsic <code>__no_operation()</code> function could give an internal error message.<br>
             [EW18396]
          <li>
             Bitfield assignments should now work correctly, even when the function call on the right-hand
             side of the assignment modifies other bitfields in the word.<br>
            [EW18460]
          <li>
              In some rare cases, a series of assignments could be optimized incorrectly, for example assignments like:
<PRE>x = ...;
y = x;
x = !z;
...
use(y);
</PRE>
              [EW18540]
          <li>
            Using <b><code>#pragma optimize</code></b> to lower optimization level for a function no longer 
            affect optimization of static accesses in other functions.<br>
            [EW18582]
          <li>
            An optimization can lift a global variable to a register in a code region.
            In some rare cases the register was not written back to the variable on all paths from the region.<br>
            [EW18814]
      </ul>

    <h4><A NAME="his440A">V4.40A 2006-06-03</A></h4>
    <b>Program corrections</b>	
      <ul>
        <li>
            In some rare cases, the optimizer incorrectly transformed a <code>for</code> or a <code>
              while</code> loop to a <code>do</code> loop if: the loop test compared the loop 
            counter to a variable (<code>V</code>) that was invariant in the loop, and the loop 
            was preceded by an if-else-if-statement where the else-if-test tested <code>V</code>
            against a constant value.<br>
            [EW17723]
        <li>
            High optimization could, in some rare cases, incorrectly hoist a common 
            subexpression (1) across the initialization of another common subexpression (2) 
            where (2) was the value of a global pointer variable and (2) appeared as a 
            subexpression in (1).<br>
            [EW17754]
        <li>
            Saturate idiom was recognized even at low or no optimization making the code 
            harder to debug.<br>
            [EW17802]
        <li>
            An ARM-mode peephole optimization could optimize a MUL + ADD to MLA even thou 
            the ADD had a shifted operand.<br>
            [EW17833]
        <li>
            Functions with inline assembler with labels could incorrectly be inlined.<br>
            [EW17862]
        <li>
            Incorrect code could in some cases be generated in thumb mode for saturate 
            idiom.<br>
            [EW17868]
        <li>
            Inlining of functions where a pointer parameter was declared volatile could in 
            some case result in incorrect code.<br>
            [EW17902]
        <li>
            The result of the instruction scheduling could in some cases differ between 
            compilations with same input.<br>
            [EW17919]
        <li>
            Functions that dereferenced a pointer after testing if it was NULL could be optimized 
            incorrectly.<BR>
            [EW18038]
        <li>
            Loops that added invariant expression to an indirection of an invariant pointer and the loop 
            index variable (p[i] += 4711) could in some cases be optimized incorrectly.<br>
            [EW18089]
        <li>
            Unaligned store of zero could give internal error if neighbored with another zero store.
            <pre>
            char charr[100];

            *(int*)(&charr[1]) = 0;
            charr[5] = 0;
</pre>
            Note that this kind of code probably will not execute correctly, since most ARM architectures
            do not support unaligned accesses.<br>
            [EW18124]
      </ul>
      <b>New features</b>  	  
	  <ul>
        <li>
          Support for the Cortex-M series has been added.
        <li>
          Output from the compiler is now in unified assembler syntax.
        </li>                
      </ul>


    <h4><A NAME="his431A">V4.31A 2006-02-03</A></h4>
    <b>Program corrections</b>	
    <ul>
      <li>
        Invariant assignments could in some cases incorrectly be hoisted out of <code>for</code>
        or <code>while</code> loops, if the loop test contained an <code>||</code> operator.<br>
      [EW16986]
      <li>
        High optimization could in some cases generate incorrect code for nested loops 
        if the inner loop was not executed for every iteration of the outer loop.<br>
      [EW17010, EW17064]
      <li>
        The compiler could in some rare cases loop if the outcome of the condition in a 
        conditional (<code>? :</code>) expression could be determined by assignments in the 
        preceding basic blocks.<br>
      [EW17026]
      <li>
        Nested irq functions did not return properly.<br>
      [EW17032, EW17033, EW17038]
      <li>
        A <code>char</code> or <code>short </code>loop counter initialized with a function call 
        could in some cases result in an internal error.<br>
      [EW17039, 17179]
      <li>
        Assignments to an auto array could incorrectly be removed as dead code if the 
        only use of the array, besides assignments to it, was to assign the array 
        address to a global pointer.<br>
      [EW17041]
      <li>
        Incorrect interpretation of the <code>Z</code> flag when analyzing a <code>CMN</code> instruction 
        could lead to incorrect optimizations.<br>
      [EW17065]
      <li>
        Accessing a data member of a base class of a class object returned by value 
        from a function call no longer results in an internal error.<br>
        Example: <code>fun().x</code>, where <code>x</code> is a data member of a base class of 
        the type returned by <code>fun()</code>.<br>
      [EW17085]
      <li>
        Optimization of a function tail call into a branch instruction in a thumb 
        function that takes stack parameters generated wrong stack offset to the stack 
        parameters.<br>
      [EW17117]
      <li>
        Delayed stack-cleaning in combination with stack access and a conditional (<code>? 
          :</code>) expression could generate wrong stack offset.<br>
      [EW17127]
      <li>
        Loops where the loop counter was a <code>short int</code> or <code>char</code> could 
        earlier result in incorrect code if the loop increment was negative and high 
        speed optimization was used (<code>-s9</code>).<br>
      [EW17129, 17164]
      <li>
        When constructing a vector of POD data (data with no constructors) with an 
        initial non-zero size, the elements are now correctly zero-initialized. For 
        example:<br>
        <pre>
      vector&lt;int&gt; v(3);
</pre>
        <code>v</code> should in this example contain 3 integers, each initialized to zero. 
        Previously the integers were incorrectly left uninitialized.<BR>
      [EW17160]
      <li>
        Code with both shifting and division by a constant value could in some rare 
        cases generate internal error.<br>
      [EW17162]
      <li>
        Loops where the trip count was constant and the final statement was a <code>switch</code>
        expression could in some cases cause an internal error when high optimization 
        was used.<br>
      [EW17181]
      <li>
        Incorrect code could be generated for small loops with descending access 
        patterns. For example:<br>
        <pre>      for (i = 0 ; i &lt; n; ++i)
        a[100 - i] = ...;
</pre>
        or
        <pre>      for (i = 0 ; i &lt; n; ++i)
        *(p-- + 17)= ...;
</pre>
      [EW17184]
      <li>
        The MISRA C rule 113 states that members of a structure or union shall only be 
        accessed via their name. The compiler now diagnoses a violation of this rule 
        correctly when a pointer to an element of a member array is created. For 
        example:<br>
        <pre>
      struct {
        int a;
        int b[2];
      } x;

      x.a;    /* Was diagnosed     */
      x.b[0]; /* Was not diagnosed */
</pre>
      [EW17186]
      <li>
        An <code>__swi</code> declared function pointer now correctly gives an error 
        message.<br>
      [EW17329]
      <li>
        A register transfer instruction were in some cases optimized away due to 
        incorrect optimizer analysis of sign extend operations.<br>
      [EW17330]
      <li>
        Incorrect code was generated for assignments of instances of <code>vector&lt;&gt;</code>
        in two cases:<br>
        1. The assignment of a vector where the elements could use bitwise copy and 
        where the destination vector was smaller than the source vector but had a 
        capacity that was large enough.<br>
        2. The assignment of a vector where the elements needed copying or construction 
        using member functions but did not need destruction, where the destination 
        vector was larger than the source vector.<br>
        These assignments now work correctly.<br>
      [EW17413]
      <li>
        <code>R8_fiq</code> - <code>R12_fiq</code> was unnecessarily saved when entering an fiq 
        exception.<br>
      [EW17453]
      <li>
        The internal error: <code>[Ect]: Optimize</code> has been corrected.<br>
      [EW17461]
      <li>
        An error message is now given if the <code>--segment</code> option is used more 
        than once with the same segment specifier.<br>
      [EW17463]
      <li>
        On high optimization, array initializations and assignments to array members 
        could be incorrectly removed as dead code if the only explicit use of the array 
        was to assign its address to a member in a packed <code>struct</code>.<br>
      [EW17466]
      <li>
        A problem in the instruction scheduling optimizer has been corrected. A <code>pop</code>
        instruction to restore callee saved registers could be hoisted over an 
        instruction that defined one of theses registers.<br>
      [EW17495]
      <li>
        When compiling for interwork, a redundant mode change entry will be inserted in 
        front of a generated function. This function may save information about code 
        size if the function is called from code with different mode (arm/thumb). In 
        some cases the compiler missed to generate this mode change entry. The 
        generated code is still correct but can give different code size between 
        compilations.<br>
        [EW17603]
	   </ul>
	     <b>New features</b>  
		<ul>
      <li>
        The command-line option <code>--no_path_in_file_macros</code> has been added. It 
        removes the path leaving only the filename for the symbols <code>__FILE__</code> and
        <code>__BASE_FILE__</code>.</li>
    </ul>
    <h4><A NAME="his430A">V4.30A 2005-06-23</A></h4>
    <b>Program corrections</b>		
    <ul>
      <li>
          The compilation time is now reasonable when the source code
          contains hundreds of global variables and is compiled
          with high optimization level.<br>
          [EW14199]
      </li>
      <li>
        Warning Pa084 ("pointless integer comparison with out of range value") will no 
        longer be issued erroneously in cases where a relational operator is used with 
        a template non-type parameter of integer type.<br>
      [EW16367]
      <li>
        Some float NaN patterns were not correctly converted to double.<br>
      [EW16373]
      <li>
        Using compound literals, a C99 feature, could result in an internal error in 
        the compiler.<br>
      [EW16412]
      <li>
        Inline assembler code with illegal instructions like <code>MOV R0,@R1</code> could 
        generate an internal error<br>
      [EW16414]
      <li>
        An inline-assembler statement containing nothing but a newline character could 
        cause an internal error in the compiler. Example: asm("\n");<br>
      [EW16415]
      <li>
        A label placed on the first line of a multi-line inline-assembler statement 
        could cause errors.<BR>
        Example:<pre>   asm("loop:\n"
       " bra loop"); </pre>
      [EW16417]
      <li>
        Loops with multiple assignments to an auto variable could result in incorrect 
        code, when the loop also contained partial accesses (with a non-zero offset) to 
        the auto variable.
        <pre>void ByteSwap128(short *addr)
{
&nbsp;&nbsp;int i;
&nbsp;&nbsp;short tmp;
&nbsp;&nbsp;char *dst, *src = (char *)&amp;tmp;
&nbsp;&nbsp;for (i = 0; i &lt; 64; ++i)&nbsp;&nbsp;
  {&nbsp;&nbsp;&nbsp;&nbsp;
    tmp = *addr;
&nbsp;&nbsp;&nbsp;&nbsp;dst = (char *)addr++;
&nbsp;&nbsp;&nbsp;&nbsp;dst[0] = src[1]; /* points to (char *)&amp;tmp + 1*/
&nbsp;&nbsp;&nbsp;&nbsp;dst[1] = src[0];

&nbsp;&nbsp;&nbsp;&nbsp;tmp = *addr;
&nbsp;&nbsp;&nbsp;&nbsp;dst = (char *)addr++;
&nbsp;&nbsp;&nbsp;&nbsp;dst[0] = src[1];
&nbsp;&nbsp;&nbsp;&nbsp;dst[1] = src[0];
&nbsp;&nbsp;}
}</pre>
      [EW16419]
      <li>
        The compiler now generates the same alignment for the following two 
        definitions:<br>
        unsigned char a [6] = {0,0,0,0,0,0};<br>
        unsigned char b [] = {0,0,0,0,0,0};<br>
      [EW16430]
      <li>
        Loops with a non-constant trip count (number of iterations in the loop) could 
        be uncorrectly unrolled.<br>
      [EW16439]
      <li>
        Common subexpression elimination no longer hoists expressions that incorrectly 
        can cause an exception, unless the expression is guaranteed to be executed in 
        all successors.<br>
      [EW16443]
      <li>
        Fixed a problem were iswprint erroneously returned true for the characters 
        carriage return and newline.<br>
      [EW16465]
      <li>
        Branch-chaining optimization, which is performed at the highest size 
        optimization level, could incorrectly chain a <code>BCS</code> instruction via a <code>BHI</code>
        instruction. This could cause a branch to go the wrong way at runtime depending 
        on the status of the Z-flag.<br>
      [EW16481]
      <li>
        An expression containing the new operator could generate a reference to the 
        wrong constructor when an optimization level of 6 or higher was used, at least 
        one of the parameters to the constructor was an object passed by copy 
        construction, and the constructor definition was not visible in the same 
        compilation unit as the expression containing the new operator.<BR>
        Example:
        <pre>struct X
{
  X(X const &amp;);
  ...&nbsp;&nbsp;&nbsp;
};
&nbsp;&nbsp;&nbsp;
struct Y
{&nbsp;&nbsp;
  Y(X);
  ...
};

Y * mkY(int a) { return new Y(a); }</pre>
        If the function mkY was not in the same file as the definition of Y::Y(X), a 
        reference was created to Y::new Y(X *) instead of to Y::new Y(X).<br>
      [EW16482]
      <li>
        Calculating remainder by a constant could give the wrong result at the highest 
        speed optimization level.<br>
      [EW16487]
      <li>
        Overlapping stores with zero could caused an exception in the compiler at high 
        optimizations. The compiler analyzes stores with zero to memory and optimizes 
        them. If there were instructions that wrote to overlapping memory locations, 
        the compiler could terminate with the following internal error:<br>
        <pre>
      Internal error: [Ect]: Any exception
      Fatal error detected, aborting.
      Internal error: [PostOptimize]: Any exception
      Fatal error detected, aborting.</pre>
      [EW16489,EW16491]
      <li>
        Optimizer inlining failed to recognize the #pragma location directive, leading 
        to located code being placed in the wrong segment.<br>
      [EW16529]
      <li>
        The compiler could generate incorrect code if:
        <ol>
      <li>
      A function (f) assigned a variable (p) to point to an object (o) and returned 
      the variable p,
      <li>
      the function result was assigned to a variable (q) of the same type as p,
      <li>
      the object o was modified before an access to o through q
      <li>
        and the function call to f was inlined by the optimizer.</li>
      </ol> [EW16537]
      <li>
        An optimization that tries to hold a global variable in a register during 
        several modifications of the global variable could in some cases cause 
        incorrect code.<br>
      [EW16547]
      <li>
        In some cases, a loop with an upper bound that was a signed non-trivial 
        expression divided by a power of two could result in incorrect code.<br>
      [EW16550]
      <li>
        Complex <code>?:</code> sequences could cause an internal error at the high 
        optimization level.<br>
      [EW16552]
      <li>
        When compiling EC++, constant variables initialized with simple floating point 
        expressions were put in RAM memory instead of ROM memory.<br>
      [EW16587]
      <li>
        Corrected an internal error that could occur when an assignment to an auto 
        structure contained a reference to a member in itself or another auto 
        structure.
        <pre>struct X x, y, *array;
x = array[x.m];</pre>
      [EW16606,EW16608,EW16627,EW17177]
      <li>
        A Thumb <code>MOV</code> immediate to low register could be hoisted in between a <code>CMP</code>-<code>BCC</code>/<code>BCS</code>
        sequence, which destroyed the effect of the <code>CMP</code> instruction.<br>
      [EW16611]
      <li>
        In some rare cases, values were not written to memory before a function call.<br>
      [EW16620]
      <li>
        Code that implements a saturate operation (keep a value inside a range such as 
        -128 to 127) could produce incorrect code in both Thumb and Arm mode.<br>
      [EW16626,EW16670]
      <li>
        At the high optimization level incorrect code could be generated if a loop had 
        an unsigned loop counter, the loop counter was decremented, and the loop 
        contained a test (besides the loop exit test) where the loop counter was 
        compared to zero.<br>
      [EW16646]
      <li>
        An internal error in constant table generation for functions that end with a 
        fall through to the common exit sequence has been corrected.<br>
      [EW16657]
      <li>
        Incorrect code could be produced when a "<code>Rn &lt;shift&gt; Rm</code>" operand 
        is spilled to other registers and there is an overlap between one of the 
        original registers and the new destination. The error occurred because the 
        operand was not properly reconstructed to reflect the new registers that the 
        values were moved to.<br>
      [EW16671]
      <li>
        Optimizer inlining failed to recognize <code>__ramfunc</code>, leading to that code 
        meant to be placed in RAM could end up in ROM.<br>
      [EW16698]
      <li>
        If both statements in an if else statement are identical (after removal of dead 
        code) an optimization that merges the two statements could in some cases also 
        remove side effects (for example calls or volatile accesses) in the redundant 
        condition.<br>
      [EW16735]
      <li>
        Incorrect code could be generated when the initial value for a signed loop 
        counter was computed with an &amp; expression where both operands where 
        non-constant expressions.<br>
      [EW16757]
      <li>
        Two <code>STRB</code> with zero to offset 256 and 257 could be compiled into a 
        single <code>STRH</code> which then had its offset truncated to 0.<br>
      [EW16885]
      <li>
        Coprocessor instructions MCR and MRC are no longer moved around by the 
        instruction scheduler. They previously were allowed to be move past a volatile 
        side effect.<br>
      [EW16886]
      <li>
        If a loop with a variable upper limit was preceded by a modification of the 
        upper limit and a test of the upper limit being larger than the lower limit of 
        the loop, the optimizer could incorrectly assume the loop body should always be 
        entered.
        <br>
        <pre>    if (u &gt; 0)
      {
        --u;
       for (i = 0; i &lt; u; ++i)
        {
          ...
        }
     }</pre>
      [EW16887]
      <li>
        Including an I/O definition header and referencing more than one SFR from C++ 
        code will no longer result in incorrect "more than one definition for 
        struct/union type" warnings when linking.<br>
      [EW16957]
      <li>
        Unrolling of loop with non-constant trip count could cause internal error in 
        the optimizer.<br>
        [EW17006]
	  </ul>
      <b>New features</b>  	  
	  <ul>
      <li>
      Support for ARM11 and V6 has been added.
      <li>
      The execution speed of the floating point library has been significantly 
      improved.
      <li>
      Code size and speed performance have been improved for both ARM and Thumb.
      <li>
      It is now possible to declare variables in the initialization clause of a for 
      statement, but only in extended language mode. This behavior is according to 
      the C99 and the C++ standards.
      <li>
        You can now compile several source files in one compilation by specifying the 
        command line option --mfc. The advantage of multi-file compilation is that it 
        gives the interprocedural optimizations a larger set of functions to work on. 
        If you also specify the command line option --discard_unused_publics, the 
        optimization will be further improved because the compiler will assume that 
        there are no references to any symbol from the outside in the compilation, i.e. 
        the compilation unit is the whole application apart from the library.<br>
      Use the --mfc option with caution, because it is experimental in this version 
      of the compiler.
      <li>
        Some more C99 functionality has been added to the IAR DLIB Library:<br>
        <ul>
          <li>
          Ctype.h defines isblank as an added function.
          <li>
          Inttypes.h has been added. Note that only the conversions are included, not the 
          functions.
          <li>
            Math.h defines the following additions:<br>
            Macros - HUGE_VALF, HUGE_VALL, INFINITY, NAN, FP_INFINITE, FP_NAN, FP_NORMAL, 
            FP_SUBNORMAL, FP_ZERO, MATH_ERRNO, MATH_ERREXCEPT, math_errhandling.<br>
            Typedefs - float_t, double_t.<br>
            Macro functions - fpclassify, signbit, isfinite, isinf, isnan, isnormal, 
            isgreater, isless, islessequal, islessgreater, isunordered.<br>
          <li>
          Stdlib.h defines llabs, lldiv, strtoll, strtoull, atoll, strtof, and strtold as 
          added functions.
          <li>
          Wchar.h defines vfwscanf, vswscanf, vwscanf, wcstof, and wcstolb as added 
          functions.
          <li>
            Wctype.h defines iswblank as an added function.</li>
        </ul>
      </li>
    </ul>
    <h4><A NAME="his420A">V4.20A 2005-01-10</A></h4>
    <ul>
      <b><u>Program corrections</u></b><p>
        <li>
          Using <code>#pragma vector</code> on an interrupt function did not update the 
          exception vector table.<br>
        [EW14086]
        <li>
          A function definition at a line number greater than 65535 could cause an 
          internal error, due to an unused line number field in an object file record 
          that overflowed.<br>
        [EW15542]
        <li>
          Call to an <code>__irq</code> or <code>__fiq</code> function could generate an internal 
          error.<br>
        [EW15561]
        <li>
          <code>__ramfunc</code> functions shared relay functions with non <code>__ramfunc</code> 
          functions in the same module. If they were placed far from each other that 
          could generate a link error.<br>
        [EW15562]
        <li>
          The scheduler failed to recognize overlapping load and store operations if they 
          were of different size.<br>
        [EW15579, EW15656]
        <li>
          A volatile load directly following a store to the exact same location could 
          reuse the stored value instead of loading it again.<br>
        [EW15582, EW15657, EW15663]
        <li>
          A declaration of a block local variable with no initialization, immediately 
          followed by a label, resulted in incorrect code in some cases.<br>
        [EW15594]
        <li>
          In some cases auto-variables of union type were optimized incorrectly. 
          Assignments to a member (m) were incorrectly removed if the union definition 
          contained a declaration of another member, of equal or larger size, below the 
          declaration of m.<br>
        [EW15595]
        <li>
          The scheduler could generate an internal error for a large basic block without 
          any statement info.<br>
        [EW15596]
        <li>
          If a function had multiple return statements and all returns were preceded by 
          an assignment to the same global variable (or an indirect assignment using the 
          same pointer), the return value could be overwritten by a temporary value.<br>
        [EW15600]
        <li>
          Some caller-saved registers were not saved when calling library routines for 
          floating point subtraction and division.<br>
        [EW15601]
        <li>
          Fall through to a large 'common exit sequence' with several constant references 
          could generate constant entries out of bounds.<br>
        [EW15613]
        <li>
          <code>AND</code> with a constant that was converted to <code>BIC</code> on a variable 
          smaller than 32 bits could leave garbage in the higher bits of the register.<br>
        [EW15621]
        <li>
          In some cases auto-variables of structure type caused an internal error if the 
          structure had a member of union type.<br>
        [EW15622]
        <li>
          A register parameter could in rare circumstances be allocated in the same 
          register (or overlapping register) as another local variable.<br>
        [EW15623]
        <li>
          Hoisting of loop-invariant code could in some rare cases generate incorrect 
          code.<br>
        [EW15624]
        <li>
          Code optimized to a conditional tail jump could generate an internal error.<br>
        [EW15625]
        <li>
          A basic block could in some cases be flattened even if it had multiple 
          predecessors with different flags set.<br>
        [EW15627, EW15768]
        <li>
          <code>FLDS</code>, <code>FLDD</code>, <code>FSTS</code> and <code>FSTD</code> can now have 
          relocatable offset. This is needed when accessing constants from vfp code.<br>
        [EW15641]
        <li>
          Constant entries could in some cases, especially large <code>long long</code> switches, 
          be placed among the switch data. This could lead to random jumps anywhere in 
          memory.<br>
        [EW15643,EW15660,EW15661,EW15665]
        <li>
          Invariant definitions were in some cases hoisted even if it defined alive 
          non-invariant resources or used a non-invariant resource.<br>
        [EW15646]
        <li>
          Offset check for constants placed in another segment part was too pessimistic. 
          This could lead to internal error.<br>
        [EW15653,EW15654]
        <li>
          In some rare cases the compiler performed incorrect optimizations (for example 
          constant propagation or common subexpression elimination) of accesses through 
          pointers. The effects were noticeable when the same data object was accessed 
          through different pointers. The problem was unlikely to occur in non-trivial 
          functions.<br>
        [EW15655]
        <li>
          <code>long long</code> switch in thumb mode could generate unaligned accesses.<br>
        [EW15659]
        <li>
          In some cases the compiler tried to flatten a basic block ending with a table 
          switch. This generated broken code.<br>
        [EW15664]
        <li>
          In some cases union accesses were optimized incorrectly. The union accesses 
          could only have two sizes and one of the sizes must be the whole union. 
          Accesses of the two differing sizes must be interleaved so the contents of the 
          union was read with a different size than the value stored in the union.<br>
        [EW15681]
        <li>
          The intrinsic <code>__no_operation()</code> could be optimized away in Arm mode.<br>
        [EW15690]
        <li>
          When a volatile-declared variable was used in the index expression of a 
          volatile-declared array expression, the compiler issued an incorrect warning 
          about undefined order of volatile accesses.<br>
        [EW15710]
        <li>
          The #pragma vector was broken in several ways.<br>
          1. The segment part was generated as noroot causing the linker to remove it.<br>
          2. Multiple vector numbers was not recognized.<br>
          3. The vector number was scaled wrongly.<br>
        [EW15781]
        <li>
          When typedefs were involved in an integer comparison, the compiler sometimes 
          incorrectly issued the warning Pa084 (pointless integer comparison with out of 
          range value) for cases where such a warning was inappropriate.<br>
        [EW15793]
        <li>
          Swi vector for declared only functions was sometimes treated as 0.<br>
        [EW15862]
        <li>
          A thumb peephole pattern which propagates an <code>ADD</code> instruction beyond a <code>
            LDR</code>/<code>STR</code> instruction by modifying the addressing mode of the <code>LDR</code>/<code>STR</code>
          instruction did not take care of all situations properly with respect to flags 
          being alive after the instruction.<br>
        [EW15898, EW16191]
        <li>
          The compiler could generate wrong debug information for local variables causing 
          them to be shown as unavailable in the debugger watch window.<br>
        [EW15948]
        <li>
          Complex expressions containing a signed division with a constant denominator 
          could in some cases cause an internal error.<br>
        [EW16000]
        <li>
          Evaluation of expressions with the <code>%=</code> operator now follows the rules 
          for integral promotion.<br>
        [EW16001]
        <li>
          The internal header file <code>xlocale.h</code> did not work properly when the 
          current locale was the C locale (which it typically is) and the symbol C was 
          defined as a preprocessor macro.<br>
        [EW15602]
        <li>
          The use of a variable (x) could incorrectly be eliminated from an expression, 
          if 1. the expression contained both a use and a defining use of x and 2. the 
          expression contained a use of another variable (b) that was the single use of 
          it 3. no defining use of x occured before b's defining use
          <pre>
      void use(int);
      int broken(void)
      {
        int x; /* x uninitialized */
        int a = 1;
        int b = 2; /* b's definition */

        x = a; /* this defining use of x is overlooked */
        use(x);
        x = b + x; /* use and def of x, use of b */
        use(x);

        return x;
      }
</pre>
        [EW16002]
        <li>
          The compiler now attempts to warn about undefined behavior in some situations 
          involving sequencing or multiple modifications with no intervening sequence 
          point. If this warning involved data accessed through the implicit <code>this</code>
          pointer of a C++ member function, an internal error resulted.<br>
        [EW16021]
        <li>
          The scheduler could rearrange code including a constant load to VFP register 
          even when conflicts would appear.<br>
        [EW16051]
        <li>
          An initialized <code>auto</code> array inside a loop no longer causes an internal 
          error.<br>
        [EW16052]
        <li>
          Relay function to <code>div</code>/<code>mod</code> trashed R2 in thumb mode. Such 
          relay functions is needed when the distance between the caller and the callee 
          is more than 4 Mbytes.<br>
        [EW16061]
        <li>
          A problem where using the preprocessing operator <code>define</code> could cause an 
          internal error has been corrected.<br>
        [EW16076]
        <li>
          Register allocation of VFP registers could differ between compilations of a 
          specific source code depending on Windows memory allocation. The code produced 
          was correct, but not necessarily identical.<br>
        [EW16083]
        <li>
          Long functions can make use of spring board jumping which utilize existing 
          jumps to avoid generating a long branch, by forming branch chains. In one rare 
          case a conditional branch immediately preceeding the destination label could 
          incorrectly be incorporated in such sequence (its destination points elsewhere, 
          but it has fall-through flow to the target label).<br>
        [EW16097]
        <li>
          Defining a C preprocessor macro with the same name as any directory component 
          of the library configuration file path would change that component giving the 
          wrong path.<br>
        [EW16220]
        <li>
          <code>long long</code> operations such as <code>add</code>, <code>subtract</code>, <code>negate</code>
          could be incorrectly made if the low part of the result overlapped with the 
          upper part of one of the operands. This happened in some rare situations when 
          the register pressure was high.<br>
        [EW16331]
        <li>
          8-bytes stack alignment was not always preserved.<br>
        [EW16332]
        <LI>
          Complex pointer to data member access could generate internal error with bad 
          data alignment.<BR>
        [EW16370]
        <li>
          The compiler could terminate with<br>
          Internal Error: [CoreUtil/General]: Const_Folding<br>
          when doing a cast on pointer arithmetics.<br>
        [EW16898]
        <li>
          The common subexpression elimination optimization could could give different (but correct)
          output depending on compilation environment, producing slightly different (but correct)
          code between compilations.<br>
        [EW17918]
      <p></p>
	  </ul>
        <b>New features</b>  
	  <ul>
      <li>
        A new object attribute, <code>__noreturn</code> has been added. The attribute can 
        be used on functions to inform the compiler that the function will not return. 
        The compiler can then generate more efficient code. Examples of functions that 
        do not return are <code>abort()</code> and <code>exit()</code>.
      <li>
        To determine the configuration file for DLIB from the command line, use the 
        compiler option <code>--dlib_config config_file</code>. The old variant, using <code>-D_DLIB_CONFIG_FILE=config_file</code>, 
      will still work but can interfere with other preprocessor defines.
      <li>
      Support for compound literals has been added to the C language.
      <li>
        New compiler command line option <code>--preinclude include_file</code>.
      <li>
        The inline assembler operator <code>asm()</code> now supports multiple instructions 
        and local labels. Example<br>
        <pre>
      asm("Loop:  MOV R0,#10     \n"
          "       ADD R3,R3,R2   \n"
          "       SUB R0,r0,#1   \n"
          "       BNE Loop");
</pre>
        Note that the instruction separator is <code>'\n'</code> and that the definition 
        and the reference of a local label do not necessarily need to be in one <code>asm()</code>.</li>
    </ul>
    <h4><A NAME="his411A">V4.11A 2004-06-10</A></h4>
    <ul>
      <li>
        The following C99 features can now be used in the C language if language 
        extensions (-e) are enabled:
        <ul>
          <li>
            The <code>inline</code> keyword. It works as the C++ inline keyword (and the <code>#pragma 
              inline</code>
          declaration).
          <li>
          Mixing declarations and statements within the same scope.
          <li>
            Having a declaration in the initialization expression of a for-loop.</li>
        </ul>
      <li>
        The standard library <code>fopen()</code> function incorrectly worked and returned 
        a valid file pointer, even when not linking the application with the debug 
        information without I/O emulation modules, available by choosing <b>Project 
          Options</b> and selecting the <b>Linker category</b>.<br>
      [EW13922]
      <li>
        In rare cases at high optimization levels, the optimizer data flow analysis 
        could fail with an internal error.<br>
      [EW15026]
      <li>
        The namespace scope of extern "C" functions was incorrectly included in their 
        linker visible names, which sometimes could lead to incorrect Undefined 
        External errors when linking.<br>
      [EW15088]
      <li>
        Instruction scheduling could in some cases change the order of two volatile 
        read accesses.<br>
      [EW15119]
      <li>
        In some cases an array element reference could be optimized incorrectly if the 
        address was computed in two separate expressions and both contained the loop 
        counter. For example.
        <pre>  int a[100][100];
  int foo()
  {
    int i;
    for (i = 0; i &lt; 10; ++i)
    {
      int *p = &amp;a[i][0];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* first use of i */
      p[i * 2] = 4711;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* second use of i */
    }
  }</pre>
      [EW15123]
      <li>
        If all paths to a switch statement with a single variable as a switch 
        expression contained assignments to the variable, it could in some rare cases 
        cause the compiler to loop when all the jumps to the switch were redirected to 
        their destination into the switch body.<br>
      [EW15131]
      <li>
        Functions declared <code>__swi</code> and with calls to other functions could 
        generate an internal error.<br>
      [EW15327]
      <li>
        The <code>va_start1()</code> intrinsic function incorrectly gave a warning when the 
        option <code>require_prototypes</code> was used.<br>
      [EW15328]
      <li>
        Switch on character expression with all case values between 0x80 and 0xFF could 
        generate incorrect code.<br>
      [EW15349]
      <li>
        Too agressive optimization could incorrectly casuse a needed <code>AND</code> instruction 
        to be removed.<br>
      [EW15396]
      <li>
        The treatment of the <code>#pragma segment</code> directive has been changed to 
        allow multiple equivalent declarations of the same segment.<br>
      [EW15413]
      <li>
        A switch statement with case values in a range greater than 255 could generate 
        an internal error.<br>
      [EW15462]
      <li>
        The compiler printed diagnostic text contained the obsolete segment types <code>HUGEDATA</code>
        and <code>HUGECONST</code> instead of <code>DATA</code> and <code>CONST</code>.<br>
      [EW15464]
      <li>
        Library call from located functions could incorrectly cause reference to 
        undefined symbol.<br>
      [EW15465]
      <li>
        A function with a parameter of type pointer to class could sometimes get an 
        incorrect name in the object file, resulting in an 'undefined external' error 
        when linking. For this to happen, the class must have a user-defined or 
        non-bitwise compiler generated copy constructor, and there must be a definition 
        of another function in the same module returning the class by value. That 
        function must, apart from the pointer to class parameter, be declared with the 
        same parameter types as the first function.<br>
      [EW15466]
      <li>
        An ARM function compiled for VFP with an integer parameter located in register 
        and later stored on the stack could generate an internal error.<br>
      [EW15469]
      <li>
        No relay function was generated for calls to <code>__ramfunc</code> functions 
        declared in the same module even though the distance was too far for the <code>BL</code>
        instruction.<br>
      [EW15485]
      <li>
        The shift count was not properly zero extended for <code>long long</code> shifts.<br>
      [EW15500]
      <li>
        If a register was used in a loop only by a single instruction, that register 
        could incorrectly be considered as dead after the refering instruction.<br>
        [EW15612]
      </li>
    </ul>
    <h4><A NAME="his410B">V4.10B 2004-03-09</A></h4>
    <ul>
      <li>
        Two new intrinsic functions are now available in the compiler, <code>__MCR()</code> 
        and <code>__MRC()</code>. They make it possible to access coprocessor registers 
        from C and C++, and not just from assembler language. <code>__MCR()</code> inserts 
        a coprocessor write instruction, <code>MCR</code>, and <code>__MRC()</code> inserts a 
        coprocessor read instruction, <code>MRC</code>. For syntax details, please see the <em>
          inarm.h</em>
      header file.
      <li>
        A new compiler command line option, <code>--separate_cluster_for_initialized_variables</code>, 
        has been added to separate initialized and uninitialized variables, when using 
        variable clustering. The use of this option can make the <code>*_ID</code> segments 
        smaller at the expense of code size. Variable clustering is disabled altogether 
        by the <code>--no_clustering</code>
      command line option.
      <li>
        A new compiler keyword, <code>__nested</code> is available to allow nested 
        interrupts. The keyword modifies the enter and exit code of an interrupt 
        function to allow interrupts to be enabled and to be served inside the 
        interrupt function without overwriting the <code>SPSR</code> and return address in <code>
          R14</code>. Nested interrupts are only supported for <code>__irq</code> functions. 
        For example:
        <pre>
  __irq __nested __arm void interrupt_handler(void);
</pre>
      <li>
        Some <b>ISO C99 features</b> have been added. They are available when language 
        extensions are enabled.
        <ul>
          <li>
            Support for the bool data type, if the header file <code>stdbool.h</code>
          has been included.
          <li>
          _Pragma support. This operator works as the pragma directive and can be used in 
          macro definitions.
          <li>
            Variadic macro support. You can now write printf-style macros.<br>
          <li>
            Hexadecimal floating point constants support. This means the ability to exactly 
            specify a floating point constant. The functions strtod(), printf(), and 
            scanf()&nbsp; recognize the syntax.<br>
          <li>
            The macro definition <code>__func__</code>. If used in a function, it is defined 
          to the name of the function.
          <li>
          Designated initializers. Using these, you can initialize a specific element in 
          a structure or a specific element in an array.
          <li>
            Inline functions. The pragma directive <code>inline[=forced]</code>
          has been added as well.
          <li>
            <code>long long</code> support in the library. For example the functions strtoll(), 
            strtoull() have been added as well as support for them in printf() and scanf().<p></p>
          </li>
        </ul>
      <li>
        The <code>localtime</code> C++ runtime library function generates negative values 
        for the <code>tm_mday</code> element.<br>
      [EW12510]
      <li>
        The compiler could generate an internal error when performing live-dead 
        analysis on a data pointer that was casted from a function pointer. The problem 
        was present on optimization levels medium (-z6/-s6) and high (-z9/-s9).<br>
      [EW14949]
      <li>
        No relay is generated in the following code (The compiler does not know how far 
        apart these two functions actually are...)
        <pre>
  #pragma location="CALLEE"
  __thumb void callee()
  {
	  volatile int a = 0;
  }

  #pragma location="CALLER"
  __thumb void main()
  {
	  volatile int a;
	  callee();
	  a=1;
  }</pre>
      [EW14973]
      <li>
        In the following code the relay for the call from caller() to callee() will be 
        'knocked out' by the relay entry to callee.
        <pre>
  #pragma location="CALLEE"
  __thumb __interwork void callee()
  {
	  volatile int a = 0;
  }</pre>
      [EW14975]
      <li>
        In a member function of a template class or one of its nested classes, a delete 
        expression involving a pointer to one of these classes could cause an internal 
        error when compiling.<br>
      [EW14979]
      <li>
        When compiling C++ code, the compiler could fail with an internal error when 
        the result of a struct/class/union assignment was used (for instance in a 
        chained assignment expression), the struct/class/union had no user-written 
        assignment operator, and the assignment could be performed as a bitwise 
        assignment.<br>
      [EW14981]
      <li>
        The body of the following loop was incorrectly treated as invariant.
        <pre>  struct
  {
    int x;
    int array[10];
  } s;

  void f(void);
  void g(void);

  void test()
  {
    int i;

    for(i = 0; i &lt; 8; ++i)
    {
      if (s.array[i])
      {
        f();
        return;
      }
    }
    g();
  }</pre>
      [EW14985]
      <li>
        When an inline member function was called from an __arm function, instead of 
        calling the member function the object's destructor was called.<br>
      [EW15102]
      <li>
        When an inline member function is called from an __arm function, instead of 
        calling the member function the object's destructor was called.<br>
        [EW15103]</li>
    </ul>
    <h4><A NAME="his410A">V4.10A 2004-02-21</A></h4>
    <ul>
      <li>
        Valid stack backtrace information is now available in the IAR C-SPY Debugger 
        inside the <code>__irq</code> and <code>__fiq</code> interrupt functions.<br>
      [EW12251]
      <li>
        Variables initialized to zero, either by explicitly setting them to zero in the 
        code or as default behavior when no value is given, were cleared to zero by <em>cstartup</em>. 
        A very small table entry was used to describe an entire block of memory to be 
        cleared. If such zero-initialized variables are clustered together with 
        variables that have explicit non-zero initializers, they would get explicit 
        zero bytes to be copied by <em>cstartup</em>. If the zero-initialized variable 
        was large (an array, for example), this could result in a waste of read-only 
        memory. There is a new option that can be used to correct the described 
        behavior:<br>
        <code>--separate_cluster_for_initialized_variables</code><br>
        Separate initialized and uninitialized variables, when using variable 
        clustering.<br>
      [EW12980]
      <li>
        The <code>stdout</code> stream is now buffered. Unbuffered stdio could cause slow 
        terminal I/O performance in the debugger.<br>
      [EW13609]
      <li>
        Assignments of derived class objects to base class variables (also known as 
        "slicing" assignments) where the assignment could be performed by bitwise 
        copying caused an internal error when compiling.<br>
      [EW14094]
      <li>
        Some syntax errors could cause a subsequent internal error when the <code>--require_prototypes</code>
        option was used.<br>
      [EW14107]
      <li>
        When generating a constructor or destructor for an unnamed structure or class 
        (for example, because one of its members had a constructor or destructor) an 
        internal error occurred.<br>
      [EW14149]
      <li>
        An internal error was generated for a switch case value which was out of range 
        for the switch type.<br>
      [EW14304]
      <li>
        The compiler sometimes generated incorrect code when dividing with, and 
        comparing with -1 in a single statement.<br>
      [EW14344]
      <li>
        In some cases loops with <code>long long</code> loop counters could be optimized 
        incorrectly.<br>
      [EW14345]
      <li>
        Incorrect code is no longer generated for <code>long long</code> decrements.<br>
      [EW14347]
      <li>
        Fix of several problems regarding bitfields in <code>long long</code> base types.<br>
      [EW14357, EW14361, EW14362, EW14366, EW14378]
      <li>
        An internal error with the message "Jump distance too far for B" could occur in 
        some rare situations.<br>
      [EW14358]
      <li>
        Casting between <code>float</code> and the <code>long long</code> <code>signed</code> and <code>
          unsigned</code> types failed in Thumb mode when using the software 
        floating-point runtime library. The library functions handling the casts used a 
        return sequence that was not compatible with the v4 instruction set. Therefore, 
        the Thumb state was not preserved by these casting operations.<br>
      [EW14365]
      <li>
        Side effects of function calls was not correctly handled for global bit fields.<br>
      [EW14367]
      <li>
        The intrinsic function <code>__QFlag()</code>, which is declared in <em>inarm.h</em>, 
        is now correctly acknowledged as an intrinsic function by the compiler.<br>
      [EW14405]
      <li>
        All functions (including, but not limited to, all relay functions) are now 
        KEEP_WITH_NEXT instead of REORDER. This prevents them from being reordered at 
        link time, if packed placement (-P) is used. This is only an issue for 
        applications larger than 4 Mbyte.<br>
      [EW14454]
      <li>
        Float comparison could result in an internal error at the highest optimization 
        level when using the vector floating-point (VFP) unit.<br>
      [EW14669]
      <li>
        Compares with 0.0 when generating code for VFP was sometimes done as if the 
        hardware supportes subnurmal-numbers.<BR>
      [EW14670]
      <li>
        Template functions and member functions of class templates that were not inline 
        (implicitly or explicitly) could cause an internal error in the compiler.<br>
      [EW14680]
      <li>
        The intrinsic function <code>__CLZ()</code> gave an internal error when compiled at 
        optimization levels above 3.<br>
      [EW14723]
      <li>
        The extra 'new constructor'/'delete destructor' routines generated by the 
        compiler when optimizing for space should be marked as tentative if the class 
        involved is a template class, even if the corresponding constructor/destructor 
        is not tentative. The compiler failed to do this, which could result in 
        multiply defined symbol errors when linking.<br>
      [EW14746]
      <li>
        In some cases an assignment to a member in a structure variable could be 
        erroneously eliminated, if the member was assigned a variable and that variable 
        was assigned in all basic blocks preceding the basic block containing the 
        structure variable declaration.<br>
      [EW14760]
      <li>
        Optimization no longer treats <code>~(x - y)</code> as <code>-(x - y)</code>.<br>
      [EW14788]
      <li>
        <code>Printf</code> format string characters above 0x7F were not handled correctly.<br>
      [EW14897]
      <li>
        When trying to avoid unnecessary setting of the <code>vtable</code> pointer in the 
        constructor for abstract classes, if the class has a member variable that is an 
        array of objects requiring construction, the compiler could hit an assertion in 
        the internal file <em>lower_init.c</em>.<br>
      [EW14909]
      <li>
        When generating a constructor or destructor for an unnamed structure or class 
        (for example, because one of its members had a constructor or destructor) an 
        internal error occurred.<br>
      [EW14911]
      <li>
        Converting numbers using <code>wcstoul()</code> with more than 9 decimal digits 
        gave the wrong result.<br>
      [EW14921]
      <li>
        The extra 'new constructor'/'delete destructor' routines generated by the 
        compiler when optimizing for space should be marked as tentative if the class 
        involved is a template class, even if the corresponding constructor/destructor 
        is not tentative. The compiler failed to do this, which could result in 
        multiply defined symbol errors when linking.<br>
      [EW14931]
      <li>
        A structure that only containes small integral types plus another structure of 
        small integral types generated 32-bit LDR/STR instructions when operating on 
        non-aligned data objects.<br>
      [EW15593]
      <li>
        In some situations the access to a variable could be hoisted above an 
        assignment to that variable.<br>
        [EW16828]
      </li>
    </ul>
    <h4><A NAME="his340C">V3.40C 2003-12-12</A></h4>
    <ul>
      <li>
        ELF/DWARF debug information for variables located in VFP double registers could 
        not be handled by the linker. A linker internal error was generated.<br>
      [EW14206]
      <li>
        In some cases expressions containing a negation could cause an internal error 
        if the expression below the negation was an associative and commutative 
        expression with several constants.<br>
        For example certain expressions with succeeding minus signs, as in <code>-(108000000-(temp-108000000))</code>.<br>
      [EW14293, EW14532]
      <li>
        Missing intrinsic function declarations of <code>__get_CPSR()</code> and <code>__set_CPSR()</code>
        have been added to the <em>inarm.h</em> header file.<br>
      [EW14300]
      <li>
        In some cases loops with <code>long long</code> loop counters were optimized 
        incorrectly.<br>
      [EW14345]
      <li>
        If a function that was compiled as <code>__monitor __thumb __interwork</code> did 
        not destroy any registers that had to be restored, for example if the function 
        body was empty, an internal error was generated.<br>
      [EW14445]
      <li>
        Some standard I/O library functions was linked into the application even if not 
        used.<br>
      [EW14465]
      <li>
        When common sub-expression elimination (CSE) was enabled in the compiler 
        optimizer, some constructs were previously optimized incorrectly. An example of 
        such a statement is:<br>
        <code>k = i + j + k;</code><br>
        [EW14497]</li>
    </ul>
    <h4><A NAME="his340B">V3.40B-P1 2003-10-06</A></h4>
    <ul>
      <li>
        Compiling with VFP enabled in ARM mode, and declaring a function with <code>__thumb</code>
        in the same translation unit, could cause an internal error at optimization 
        levels above 3.<br>
      [EW14210, EW14211]
      <li>
        The runtime library routine <code>??div8_a</code> has been corrected so that it now 
        makes a full 32-bit sign-extension of the divisor and dividend, as opposed to a 
        16-bit one, prior to performing the actual division operation. The previous 
        behavior was not a bug according to the C standard, but it could unnecessarily 
        lead to an "undesired" result.<br>
      [EW14239]
      <li>
        The result from signed 8- and 16-bit divide and modulo operations is now 
        (correctly) sign extended.<br>
      [EW14298]
      <li>
        Optimizations based on register content tracking did not function correctly for 
        multidimensional arrays. This could result in incorrect optimization of an 
        access to an element in a multidimensional array, if two or more paths through 
        the function could reach the access and at least one of the paths contained an 
        assignment to the same element. Single dimensional arrays could also be 
        affected if they were clustered. This problem only occured on optimization 
        levels above 3.<br>
      [EW14342, EW14354]
      <li>
        Structures small enough to fit within a register could in some cases be read 
        with incorrect alignment, that is with a single large read instruction instead 
        of several small ones. This resulted in an undefined behavior.<br>
      [EW14353]
      <li>
        The expression <code>X-(Y*Z)</code> was incorrectly coded as <code>FMSC[S|D]</code> instead 
        of <code>FNMAC[S|D]</code> when using VFP. Since this type of expressions are 
        present in the sourcecode for <code>sin()</code>, <code>cos()</code>, and <code>cosh()</code>, 
        applications using these library functions were affected.<br>
      [EW14359, EW14373, EW14389]
      <li>
        VFP function pointers were previously not recognized as the default function 
        type.<br>
      [EW14360]
      <li>
        Using VFP and casting a <code>float</code> to an <code>unsigned int</code> or <code>long</code>
        could give the wrong rounding mode depending on the rounding mode set in <code>FPSCR</code>. 
        Previously, the <code>FTOUIS</code> instruction was used, but the rounding mode of <code>
          FTOUIS</code> depends on <code>FPSCR</code> and gives the wrong result unless round 
        towards zero is set in <code>FPSCR</code>. Now, the <code>FTOUIZS</code> instruction is 
        correctly used instead.<br>
      [EW14363]
      <li>
        Using VFP and casting a <code>double</code> to a <code>signed int</code> or <code>long</code>
        could give the wrong rounding mode depending on the rounding mode set in <code>FPSCR</code>. 
        Previously, the <code>FTOSID</code> instruction was used, but the rounding mode of <code>
          FTOSID</code> depends on <code>FPSCR</code> and gives the wrong result unless round 
        towards zero is set in <code>FPSCR</code>. Now, the <code>FTOSIZD</code> instruction is 
        correctly used instead.<br>
        [EW14364]
      </li>
    </ul>
    <h4><A NAME="his340A">V3.40A 2003-07-03</A></h4>
    <ul>
      <li>
        Compiler assembly output in interwork mode could fail to assemble.<br>
      [EW13604]
      <li>
        A loop containing a condition, where a loop counter was multiplied with a value 
        greater than 1 and compared to a constant, could, if certain additional 
        conditions were met, be optimized incorrectly due to rounding errors when 
        loop-peeling optimizations were performed. For example:
        <pre>
  int i, res;
  for (i = 0; i &lt; 3; i++)
  {
    if((i * 2) &lt; 1)
      res = 0;
    else
      res = 1;
    printf("i=[%d]:res=[%d]\n", i, res);
  }
</pre>
        Loop-peeling optimizations are only attempted when there is a maximum of three 
        basic blocks within the loop and the highest optimization level (<code>-z9/-s9</code>) 
        is used.<br>
      [EW13695]
      <li>
        When using Thumb mode and a <code>long long</code>, or a value whose temporary 
        internal representation was <code>long long</code>, was part of a struct and 
        located at an offset of 124 (bytes) within the struct, the compiler sometimes 
        tried to generate syntactically illegal code. As a result, an internal error 
        was generated.<br>
      [EW13702]
      <li>
        The global optimizer could in very special cases lose track of a temporary 
        result.<br>
      [EW13925]
      <li>
        In some rare cases, the global optimizer could make incorrect assumptions of 
        the contents of a clustered variable, <code>b</code>, inside a loop. Incorrect code 
        was generated in these cases. For this to occur, the loop must reside within an 
        if-else statement, it cannot change <code>b</code> but must change another variable 
        in the same cluster, and <code>b</code> must be assigned in the other clause of the 
        if-else statement. For example:
        <pre>
  int a;
  int b;

  void f(void)
  {
    if(a &lt; b + 2)
    {
      while(a + b &lt;= 0)
      a++;
    }
    else
    {
      b = b + 2;
    }
  }
</pre>
      [EW13936]
      <li>
        In some cases, inner loops could be optimized incorrectly if the trip count 
        depended on the loop counter in a surrounding loop, the surrounding loop had a 
        trip count of 2, and the loop counter in the surrounding loop counted down.<br>
      [EW13937]
      <li>
        In some cases, nested loops could be optimized incorrectly if the exit test in 
        the inner loop jumped directly to the test in the outer loop. For example:
        <pre>
  x = ...;
  while (--x &gt; 0)
  {
    y = ...;
    while (--y &gt; 0)
    {
      ...
    }
    /* no code from outer loop here */
  }
</pre>
      [EW13942]
      <li>
        When <code>SFB</code> or <code>SFE</code> directives were used on segments containing 
        tentative segment parts (<code>PUBWEAK</code> symbols), one such tentative segment 
        part was used in the calculation of <code>SFB</code>/<code>SFE</code>, and the chosen 
        definition of the segment part was located in a different segment than the 
        tentative one, XLINK could generate the wrong value for the <code>SFB</code>/<code>SFE</code>.<br>
      [EW13972]
      <li>
        The compiler could produce different object code depending on the execution 
        environment, such as the host operating system used. However, the generated 
        code was correct in all cases.<br>
      [EW14003]
      <li>
        Signed compare on <code>long long</code> was previously performed incorrectly. The 
        generated code performed an all-signed compare, when it should have done a 
        signed compare on the high 32-bit word and an unsigned compare on the lower 
        part.<br>
      [EW14020]
      <li>
        The sign-on message for the <code>--segment</code> command line option has been 
        corrected. The sign-on message is displayed when invoking the compiler from the 
        command line by typing "iccarm" only.<br>
      [EW14044]
      <li>
        Const objects which are located at an absolute address, and either implicitly 
        initialized to zero or explicitly initialized to any value, were previously 
        incorrectly placed together with located no_init (const and non-const) objects 
        in the HUGE_AN segment. Now, they are correctly placed in the HUGE_AC segment.<br>
      [EW14050]
      <li>
        In some cases volatile global variables could lose the volatile attribute if 
        they were clustered. Clustering was performed on <code>high</code> optimization 
        level (<code>-z9/-s9</code>) only. For example:
        <pre>
  int y;
  int z;
  int volatile x;

  void f(void)
  {
    x = y;
    x = z;
  }
</pre>
      [EW14051]
      <li>
        All printf formatters, such as <code>%d</code> and <code>%s</code>, gave an incorrect 
        output when the <code>_Printf_small</code> formatter was used.<br>
      [EW14068]
      <li>
        The following example previously generated Thumb <code>ADD</code> and <code>SUB</code> instructions 
        in ARM mode, which resulted in an internal error.
        <pre>
  char x[8];
  void foo(void)
  {
    *(int*)&amp;x[1] = 1;
  }
</pre>
      [EW14070]
      <li>
        An internal error could be generated when compiling Thumb code containing 
        certain forms of 32-bit integer multiplications.<br>
      [EW14093]
      <li>
        A loop containing a condition, where a scaled loop counter was compared to a 
        constant, could be optimized incorrectly if the test was for (non-)equality and 
        the value was reached during the final iteration through the loop.<br>
      [EW14096]
      <li>
        Signed long long division with negative numbers gave wrong sign on quotient and 
        remainder.<br>
      [EW14117]
      <li>
        Long long arithmetic right shift failed if high word was all ones.<br>
      [EW14118]
      <li>
        Alignment of complex objects like character arrays is now set to 4. The 
        previous alignment of one was not a bug according to ANSI, but could cause code 
        written for other ARM compilers to fail at runtime due to unaligned accesses. 
        As an example, this could happen when casting a character pointer to an int 
        pointer.<br>
      [EW14123]
      <li>
        Passing a pointer to long long as argument to a function could cause an 
        internal error.<br>
      [EW14126]
      <li>
        Standard input in C-SPY with library buffered I/O enabled did not work. In 
        addition, redirecting stdin from a file in C-SPY caused an application error.<br>
        If library buffered I/O was disabled, the standard input worked correctly.<br>
        [EW14174]
      </li>
    </ul>
    <h4><A NAME="his330B">V3.30B 2003-03-18</A></h4>
    <ul>
      <li>
        When the compiler generated relay functions to Thumb assembler library 
        routines, for example <code>??divu32</code>, <code>??div32</code>, <code>??divu16</code>, <code>
          ??div16</code>, <code>??divu8</code>, and <code>??div8</code>, it accidentally 
        destroyed the contents of non-scratch register R11. R11 is seldom used by Thumb 
        code generation, but in ARM functions which call Thumb library code, this 
        problem could surface if relay functions were needed. Now relay functions 
        correctly use scratch register R12 instead.<br>
      [EW10737, EW13614]
      <li>
        When performing crossjump or hoisting optimizations, which is done on 
        optimization levels <code>-z9/-s9</code>, the compiler incorrectly assumed that all 
        inline assembler routines were identical. This could lead to an overly 
        aggressive use of these optimization techniques, which resulted in incorrect 
        code sequences to be generated.<br>
      [EW13638]
      <li>
        The compiler produced incorrect type information when compiling a file which 
        contained a struct, one of whose fields was a pointer to another struct, and 
        where the first struct was used in a context where its size or any offsets into 
        it were not needed. The type information for the second struct was incorrect, 
        which could lead to numerous incorrect type conflict warnings when linking.<br>
        [EW13651]
      </li>
    </ul>
    <h4><A NAME="his330A">V3.30A 2003-02-18</A></h4>
    <ul>
      <li>
        <code>va_arg()</code> now works for structs that are not word-aligned.<br>
      [EW10145]
      <li>
        Formatted I/O functions, like <code>printf</code>, can now handle <code>long long</code>.<br>
      [EW10898]
      <li>
        The combined number of variables/functions per file is no longer limited to 
        64k.<br>
      [EW12299]
      <li>
        Using the same segment name multiple times as an argument to the <code>__sfb()</code>
        or <code>__sfe()</code> intrinsic functions resulted in an internal error:<br>
        <code>Internal Error: [Front end]: compare_constants: bad address constant kind</code><br>
      [EW12783]
      <li>
        In some cases, assignments to elements in arrays with an unspecified size could 
        be removed if the same element was used exactly once later in the same basic 
        block.<br>
      [EW12790]
      <li>
        A remark that had been converted to a warning could not be suppressed using the <code>
          --diag_suppress</code> command line option.<br>
      [EW12847]
      <li>
        An internal buffer overflow could occur if a very long file name was used in 
        combination with a very long function name. When this happened, the result 
        could either be no diagnostic message, or one of the following two internal 
        errors:<br>
        <code>Internal error: [write_ABS_UBROF A01]: Illegal tag (P0: 0, P1: 0)</code><br>
        or<br>
        <code>Internal error: [any]: Unexpected exception</code><br>
      [EW12851]
      <li>
        A casted pointer expression could result in an internal error similar to:<br>
        <code>Internal Error: [AsmLine - OgAsm]: Error[43]: Illegal effective address</code><br>
        <code>ADD R1,#+0x2</code><br>
      [EW12883, EW12884]
      <li>
        Peephole optimization of additions, where the first operand was known to be 
        smaller than the type of the addition and the other operand was a negative 
        constant, did not take the effects of propagated carry bits into account. If 
        only a part of the sum was used (for example by shifting or masking the sum) 
        and those bits came from the bits known to be cleared in the first operand, the 
        result was optimized incorrectly.<br>
      [EW12973]
      <li>
        Incorrect code was generated for a pure 32-bit division when the divisor was a 
        constant with a value of 2^n, and optimization was turned on. The problem was 
        an incorrect mask constant.<br>
      [EW12975]
      <li>
        If a multiplication of two <code>long long</code> numbers was made in Thumb mode 
        inside a leaf function (a function that does not call any other functions), the 
        link register was not properly preserved for function return, which resulted in 
        an eternal loop.<br>
      [EW12979]
      <li>
        If a switch statement contained only case constants that were impossible to 
        reach due to the size of the switch expression type, an internal error occurred 
        when no optimization was used.<br>
      [EW12983]
      <li>
        Accessing an element of an array in a packed structure type could cause a 
        spurious warning:<br>
        <code>Pa039: use of address of unaligned structure member</code><br>
      [EW12997]
      <li>
        In some cases where several structure members were assigned loop invariant 
        values, the optimizer could mistakenly use the value from another member.<br>
      [EW13030]
      <li>
        The compiler could get into an infinite loop for certain loop constructs at 
        optimization level <code>-z6</code> and above.<br>
      [EW13031, EW13048]
      <li>
        An assignment from an array element to another in the same array could be 
        optimized away at optimization level 4 and above, if the only use of the array 
        after the assignment was to pass the array pointer itself to another function.<br>
      [EW13068]
      <li>
        Negating variables of type <code>long long int</code> previously generated 
        incorrect code.<br>
      [EW13077]
      <li>
        At optimization level <code>-z4</code> or higher, the compiler could give an 
        internal error with the message: <code>illegal state</code><br>
      [EW13160]
      <li>
        Incorrect code could be produced when the common subexpression and code motion 
        optimizations were turned on (optimization level 7 and above).<br>
      [EW13169]
      <li>
        Multiplying a variable with itself could result in an unpredictable instruction 
        (operand combination) being generated in Thumb mode.<br>
      [EW13171, EW13362]
      <li>
        In some cases, the sum of two expressions, where both expressions could be 
        expressed as k*x + m (k and m are constants and x is a loop variable), could be 
        calculated incorrectly.<br>
      [EW13184]
      <li>
        The compiler could hang on certain code constructs.<br>
      [EW13185]
      <li>
        There was a problem in auto-variable allocation that could cause two array or 
        struct variables to be allocated to the same space on the stack, even when they 
        were both alive at the same time.<br>
      [EW13186]
      <li>
        The code generated for a constant shifted by a 2^n scaled value inside a loop 
        was incorrect, when compiled with <em>High</em> speed optimization.<br>
      [EW13222]
      <li>
        Common subexpression elimination depended on memory allocation order and could 
        eliminate different expressions if the executing environment changed, for 
        example if different operating systems were used.<br>
      [EW13251]
      <li>
        In some cases, optimization of repeated assignments could remove an assignment 
        to an auto variable, even though it was still used.<br>
        <code>p = q; p-&gt;next = p; p-&gt;prev = p;</code><br>
        could be transformed to<br>
        <code>p-&gt;prev = p-&gt;next = q;</code><br>
      [EW13299]
      <li>
        When creating a temporary value from a common subexpression, the creation could 
        be lifted above assignments to clustered variables that were part of that 
        common subexpression. This caused the wrong clustered variable to be accessed.<br>
      [EW13332]
      <li>
        Thumb functions declared <code>__irq</code> no longer generate an internal error. 
        But note that <code>__irq</code> functions cannot be compiled as <code>__thumb</code>.<br>
      [EW13337]
      <li>
        XLINK could erroneously report a type conflict for cases where some type 
        attributes (like <code>const</code> or <code>volatile</code>) were part of a <code>typedef</code>
        type.<br>
      [EW13345]
      <li>
        If a loop contains multiple occurrences of variables that are only incremented 
        in the loop, the increments of those variables can be hoisted out of the loop. 
        The order of the hoisted increments no longer depend on memory allocation 
        order.<br>
      [EW13352]
      <li>
        When compiling a <code>new/delete</code> expression in C++ code at optimizations of <em>
          Medium</em> or <em>High</em>, and the code for the constructor/destructor was 
        not visible, the compiler sometimes referred to the special 'new 
        constructor'/'delete destructor' by an incorrect name, resulting in undefined 
        external errors when linking.<br>
      [EW13359]
      <li>
        A comma expression containing an assignment where a constant address was 
        assigned another constant, <code>*(unsigned char *)0x1234 = 17</code>, caused an 
        internal error.<br>
      [EW13375]
      <li>
        The assembler output generated from a string literal beginning with a tab 
        character could not be assembled.<br>
      [EW13552]
      <li>
        If there were several calls with a different number of parameters via a relay 
        function to a vararg or K&amp;R function, one of the parameters could be 
        destroyed.<br>
      [EW13564]
      <li>
        Inline assembler with several functions in different modes (<code>__arm/__thumb</code>) 
        in the same source file could cause an internal error.<br>
      [EW13581]
      <li>
        In some cases, a common subexpression containing a clustered variable could be 
        hoisted across a definition of that variable, if it occured in the same basic 
        block as the common subexpression.<br>
      [EW13593]
      <li>
        Incorrect code was sometimes generated when combining shift and zero extension 
        operations.<br>
      [EW13915]
      <li>
        When doing char (8-bit) arithmetics causing overflow, the generated code could 
        make use of the overflowed value, that is, a larger value than 8 bits.<br>
      [EW14191]
      <li>
        When compiling code containing a combination of left and right shifts, the 
        compiler performed an incorrect optimisation using a constant mask. This mask 
        was calculated for an unsigned int even when the actual type used was signed 
        int.<br>
      [EW14688]
      <li>
        Compiling code which used a combination of shift left and shift right, the 
        compiler did an erroneous optimisation using a constant mask. This mask was 
        calculated for an unsigned int even when the actual type used was signed int.<br>
        [EW14688]
      </li>
    </ul>
    <h4><A NAME="his321A">V3.21A 2002-09-27</A></h4>
    <ul>
      <li>
        #pragma segment = &lt;name&gt;<br>
        Declares a segment name that can be used in the segment operators 
        __segment_begin and __segment_end. Example:<br>
        <code>#pragma segment = "MYSEG" __huge</code>
      <li>
        __segment_begin(&lt;name&gt;)<br>
        __segment_end(&lt;name&gt;)<br>
        The __segment_begin operator denotes the start address of the segment with the 
        name &lt;name&gt;, which must be a string literal and must have been declared 
        in a segment pragma at an earlier point in the compilation unit. The 
        __segment_end operator denotes the address immediately after the last byte in 
        the segment. The type of these operators is pointer to void. If a memory 
        attribute is entered in the segment pragma declaring the segment, the type is 
        pointer to &lt;memory&gt; void, otherwise the type is a default pointer to 
        void. The operator given in the example has the type "void __huge *".<br>
        Example:<br>
        <code>__segment_begin("MYSEG")</code>
      <li>
        #pragma required<br>
        The #pragma required will introduce a requirement from a symbol to another 
        symbol, i.e. if the first symbol is in the produced output when linking the 
        other symbol should also be in that output. This is useful if, for instance, a 
        function that handles certain data should only be used if there is any data to 
        handle.<br>
        Syntax: #pragma required=symbol where symbol is any statically linked function 
        or variable. The #pragma must be placed in front of a symbol definition.<br>
        An example:
        <pre>
  void func(void)
  {
  // handle segment S or longVariable here
  }
  #pragma required = func  // longVariable requires f
  long longVariable @ "S"; // longVariable resides in segment S</pre>
      <li>
      The option --diagnostics_tables file|directory produces all possible 
      diagnostics to a file. The default extension is txt. Default filename, if only 
      a directory is specified, is diagnostics_tables.txt. It should only be used as 
      a separate option to the compiler. This option is usefull if you have used 
      #pragma diag... but forgot to document why, etc.
      <li>
      Libraries for big endian are now included.
      <li>
        Loop-invariant optimizations depended on OS memory allocation order.<br>
      [EW13215]
      <li>
        Inlined code could in rare cases give the following error:<br>
        Internal Error: [GoSyncStuff::FindPrecedingSync]: cannot find unique sync node.<br>
      [12852]
      <li>
        The compiler now generates the Thumb mnemonics LDRSB and LDRSH instead of the 
        older LDSB and LDSH.<br>
      [EW12310]
      <li>
        Loop optimizations could generate incorrect array index.<br>
      [EW12325, EW12326, EW12409]
      <li>
        Code that handles small unaligned structures could generate an internal error.<br>
      [EW12403]
      <li>
        Code for casting to signed and unsigned long long could sometimes result in 
        incorrect values.<br>
      [EW12404]
      <li>
        Code generated to access to nonaligned structures could be incorrect.<br>
      [EW12405, EW12406]
      <li>
        A constanttable inserted after a function that had been cross-jumped could 
        result in an internal error.<br>
      [EW12407]
      <li>
        An optimization bug could cause incorrect code to be generated.<br>
      [EW12408]
      <li>
        Short elements in a union stored in a register could be incorrectly aligned.<br>
      [EW12410]
      <li>
        A cast operation could sometimes incorrectly be optimized away.<br>
      [EW12512]
      <li>
        The code generated by the compiler could change depending on the compiler 
        execution environment. The generated code was correct but the size could 
        differ. The sensitivity to change in execution environment could be moving to a 
        different Windows OS, changing the environment settings, length of file paths 
        and other changes that could change the memory allocation order within the 
        compiler process.<br>
        [EW11219, EW12580]
      </li>
    </ul>
    <h4><A NAME="his320A">V3.20A 2002-06-18</A></h4>
    <ul>
      <li>
      The runtime model has changed from version 3.11A. The current __rt_version is 
      4.
      <li>
        ARM instruction set version 5TE is now supported.<br>
      To use it add command line option --cpu {target core or architecture name}.
      <li>
      It is now possible to mix code compiled with small and large code models.
      <li>
      The interworking code model is now supported through the new command line 
      option --interwork.
      <li>
      The calling convention is now ATPCS as default. Interwork must still be added 
      if needed to a function with function-type attribute __interwork or globally 
      with the command line option --interwork.
      <li>
      Access to floating point flags has been re-engineered. Refer to the file 
      MathFloatFlags.h for more information.
      <li>
      Two functions from the ANSI C99 standard have been included: snprintf() and 
      vsnprintf().
      <li>
        Evaluation of else-if could be performed incorrectly at high speed optimization 
        in Thumb mode.<br>
      [EW12287]
      <li>
        The char pointer member of a structure object used as parameter was not passed 
        correctly to the called function. This occurred at high optimization levels.<br>
      [EW12248]
      <li>
        The combination of Thumb mode and high speed optimization could lead to 
        incorrect code when testing bitfield values.<br>
      [EW12227]
      <li>
        Structure return values from __pcs functions that are less than 32-bit and not 
        aligned to an even 4-byte address would be returned indirectly using an 
        implicit extra parameter.<br>
      [EW10358]
      <li>
        Register mismatch in debug information between compiler and linker when output 
        was ELF/DWARF.<br>
      [EW10703]
      <li>
        Library functions assert, strchr and strrchr could not be used with string 
        literals in C++.<br>
      [EW10899]
      <li>
        The compiler could previously generate multiplication instruction with 
        undefined behavior: MUL R0,R0,R4.<br>
      [EW11114]
      <li>
        The intrinsic functions __sfb/sfe could only be used once per segment, multiple 
        uses would result in link failure.<br>
      [EW11122]
      <li>
        A small part of the runtime library was broken. It used the wrong register in a 
        BX instruction.<br>
      [EW12060]
      <li>
        Certain __swi function definitions could result in an incorrect warning.<br>
      [EW11247]
      <li>
        The compiler generated incorrect code for switch statements where the body code 
        and at least one case except the last did not end with a break or a goto.
        <br>
      [EW11336, EW11337, EW11360]
      <li>
        The compiler could generate incorrect code for a bitfield value test at 
        high-speed optimization.<br>
      [EW11371]
      <li>
        Nested loops using the same loop variable could be optimized incorrectly if the 
        increment or decrement of the loop variable preceded the inner loop.<br>
      [EW11372,EW11423]
      <li>
        Read access to smaller union fields in register allocated unions could destroy 
        other union fields of different size.<br>
      [EW11373, EW11381]
      <li>
        Some code optimization and analysis problems were corected. They either 
        resulted in "Internal error" or the compiler never terminated.<br>
      [EW11374, EW11375, EW11376]
      <li>
        Corrected a problem where partial object assignments were interpreted as an 
        assignment of the whole object. This could cause incorrect elimination of 
        assignments.<br>
      [EW11377, EW11418, EW11424, EW11427]
      <li>
        The compiler is now a little more restrictive when optimizing address 
        expressions. This avoids incorrect assumptions while compiling code that does 
        not conform to ANSI C.<br>
      [EW11378, EW11422]
      <li>
        Variable initialization could in some cases be optimized away.<br>
      [EW11380]
      <li>
        Sometimes loops that were unrolled to straight line code could be optimized 
        incorrectly.<br>
      [EW11416, EW11425]
      <li>
        When for or while loops were fully unrolled, side effects in the test would not 
        be executed for the final iteration.<br>
      [EW11417, EW11426]
      <li>
        Expressions like a &gt; b + 1 were rewritten as a &gt; = b, but that changed 
        the behavior when the expression b + 1 would have overflowed.<br>
        The ANSI C standard allows the transformation, since the behavior at overflow 
        is unspecified. But the expressions are no longer transformed since it changed 
        the expected behavior.<br>
      [EW11490, EW10978]
      <li>
        Using integer division or modulo in __ramfunc could result in an internal 
        error.
        <br>
      [EW11999]
      <li>
        Relay from located functions could result in:<br>
        Internal error [OgModuleLabels::Def::Define]: Label already defined.<br>
      [EW12011]
      <li>
        A number of code-generation and optimization bugs have been corrected.<br>
        [EW11419, EW11420, EW11421,EW11862]<br>
      <li>
        The file checkDefs.i included by cstartup.s79 was missing from the 
        distribution.<br>
      [EW11223]
      <li>
        The code generated for __disable_interrupt() has been rewritten in a more 
        secure way.<br>
      [EW11143]
      <li>
        Crossjump between two or more small functions could destroy LR is the distance 
        between them is too far.<br>
        [EW12808]
      </li>
    </ul>
    <h4><A NAME="his311A">V3.11A 2001-12-04</A></h4>
    <ul>
      <li>
      The floating point library now has exception flags. Refer to the file 
      MathFloatFlags.h for more information.
      <li>
      Long long is now supported, except in the formatted I/O functions.
      <li>
      A new command line option, --omit_types, omits function/variable type info in 
      object output.
      <li>
        An assignment between two elements from packed structures could generate a 
        misaligned access.<br>
      [EW10299]
      <li>
        Structure parameters to __pcs functions larger then 64 bit or not aligned to an 
        even 4-byte address were always placed on the stack.<br>
      [EW10357]
      <li>
        __pcs functions could in some cases get incorrect backtrace information.<br>
      [EW10359]
      <li>
        Several corrections in long long support.<br>
      [EW10364]
      <li>
        Loop optimization could hoist an expression before its definition.<br>
      [EW10421]
      <li>
        String literals now have the type "array of const char" in C++.<br>
      [EW10542]
      <li>
        Values casted to and compared in a type smaller than 32-bit could be destroyed.<br>
      [EW10569]
      <li>
        When compiling a while loop following immediately after a case label in a 
        switch, the compiler could crash if high optimization was used (-s9 or -z9).<br>
      [EW10725]
      <li>
        The intrinsic functions __sfb, __sfe and __sfs yield an error when the referred 
        segment is not otherwise used in the module.<br>
      [EW10757]
      <li>
        Cross call optimization could generate a fatal error in some cases where 
        several similar functions had multiple exits.<br>
      [EW10807]
      <li>
        Register allocation could in some rare cases with extreme register pressure 
        generate a "coloring failed" error.<br>
        [EW10868]
      </li>
    </ul>
    <h4><A NAME="his310A">V3.10A 2001-10-02</A></h4>
    <ul>
      <li>
      The runtime model has changed from version 2.10. The current __rt_version is 2.
      <li>
      New floating point library with smaller code size and greatly improved speed.
      <li>
      Debug information is improved, with better variable information and backtrace.
      <li>
        A switch statement of the form switch(a-b&lt;=0) at higher optimization levels 
        than 3 caused the wrong case to be selected.<br>
      [ARMC0021]
      <li>
        Inline expansion of memcpy() could produce the wrong result.<br>
      [ARMC0022]
      <li>
        Assignment loop using loop index caused incorrect code at -z9.<br>
      [ARMC0027]
      <li>
        Bitfields could not be larger than 255 bits.<br>
      [LB397]
      <li>
        Global optimizer problems which resulted in internal error has been corrected<br>
      [EW10178 (LB399)]
      <li>
        Global optimizer problems which resulted in incorrect code has been corrected.<br>
      [EW10082, EW10102, EW10180 (LB401), EW10181 (LB402), EW10182 (LB403)]
      <li>
        Call via function pointer now sets the correct mode bit in return address.<br>
      [EW10313]
      <li>
        A problem in the register allocation algorithm could cause "Internal error: 
        [CgDriver]: Coloring failed".<br>
      [EW10087]
      <li>
        Too aggressive optimizations when shifting bitfields.<br>
      [EW10080]
      <li>
        Call to a variadic __pcs function with K&amp;R declaration with different 
        number of arguments could cause an internal error.<br>
      [EW10083]
      <li>
        A faulty optimization rule could cause Thumb instructions to use illegal high 
        registers.<br>
      [EW10292]
      <li>
        Header files for C++ not installed.<br>
      [EW10294]
      <li>
        The gmtime() could cause corrupt tm structure values for arbitrary time values, 
        the tm_mday for example could turn negative. There was also a problem that the 
        mktime() function could corrupt tm structure values.<br>
        [EW10363]
      </li>
    </ul>
    <h4><A NAME="his210D">V2.10D 2001-06-27</A></h4>
    <ul>
      <li>
        Loop optimizations have been reorganized and several problems have been 
        corrected.<br>
      [Lb 355,375,376,379,382,390,396]
      <li>
        Corrected a problem in the ARM mode peephole optimizations. Could cause an 
        unintialized register to be used.<br>
      [ARMC0018]
      <li>
        Corrected a problem that caused compiler to loop if ARM mode was used and the 
        code had a large modulo expression.<br>
      [ARMC0017]
      <li>
        Part of the exit sequence could be optimized away (restoring high registers in 
        Thumb mode).<br>
      [ARMC0016]
      <li>
        Fixed problem where a constant casted to a pointer caused incorrect code 
        randomly.<br>
      [ARMC0015]
      <li>
        CStartup used to have a reference to SVC_STACK that was neither used in the 
        code nor declared in the standard linker command file lnkarm.xcl.<br>
      [ARMC0011]
      <li>
        #pragma swi_number can now be fitted to either the function declaration or the 
        function definition.<br>
      [ARMC0009]
      <li>
        Fixed code for passing structures as parameters. The code was either incorrect 
        or the stack was not aligned correctly.<br>
        [ARMC0007]
      </li>
    </ul>
    <h4><A NAME="his210A">V2.10A 2001-02-21</A></h4>
    <ul>
      <li>
      The compiler now supports Embedded C++.
      <li>
      It is now possible to choose between big and little endian byte order.
      <li>
      Support for the ARM9TDMI core has been added.
      <li>
        The following command line options have been added or changed:
        <ul>
          <li>
            <code>--ec++</code>
          add support for ec++ syntax
          <li>
            <code>--cpu [arm7tdmi | arm9tdmi]</code>
          select processor
          <li>
            <code>--endian [big | little]</code>
          select memory format
          <li>
            <code>--no_scheduling</code> disables instruction scheduling</li>
        </ul>
      <li>
        A program with struct accesses in different scopes but casted from the same 
        variable could be transformed incorrectly.<br>
      [Lb 388]
      <li>
      Too aggressive optimizations with partial updates of variables.
      <li>
      A change of sign was sometimes introduced in unsigned character switches.
      <li>
        Incorrect code was generated in loops at high speed optimizations.<br>
      [Lb 381]
      <li>
        An internal error was received when the &gt; operator was used with unequal 
        types in loops at high optimizations.<br>
      [Lb 380]
      <li>
        The recognition code for packed structures was incorrect.<br>
      [Lb 378]
      <li>
        A problem occuring when accessing fields in packed structures has been 
        corrected.<br>
      [Lb 374]
      <li>
        Accessing array members of struct return values could give an internal error.<br>
      [Lb 365]
      <li>
        Correcting a problem occuring in Thumb mode on high optimization level when 
        adding a constant offest to an address (label).<br>
      [ARMC0004]
      <li>
        The following code used to give an internal error:<br>
        <code>int fn_dbl(double);</code><br>
        <code>int fn_dbl(f) float f; { do_nothing(&amp;f); return 97; }</code><br>
        [Lb 364]</li>
    </ul>
    <h4><A NAME="his130C">V1.30C 2000-10-14</A></h4>
    <ul>
      <li>
        A problem in cstartup has been corrected, constants where put after each 
        segment even when fall-through was used.<br>
      [ARMC0003]
      <li>
        A problem sometimes resulting in an internal error "coloring failed" in Thumb 
        mode has been corrected.<br>
        [ARMC0002]
      </li>
    </ul>
    <h4><A NAME="his130A">V1.30A/B 2000-09-28</A></h4>
    <ul>
      <li>
        Support for handling interrupt functions has been added.<br>
        The following function type attribute keywords have been added:
        <ul>
          <li>
          __irq - declares an interrupt function.
          <li>
          __fiq - declares a fast interrupt function.
          <li>
            __swi - declares a software interrupt function.</li>
        </ul>
      <li>
        The following #pragma directive has been added:<br>
        <code>#pragma swi_number=&lt;number&gt;</code><br>
      For more information about interrupt functions, see Manual corrections in this 
      document, tutor\interrupt_example.c, inc\arm_interrupt.h, and 
      src\lib\swi_handler.s79.
      <li>
        The following intrinsic functions have been added:
        <ul>
          <li>
            <code>__intrinsic int __sfb(void *)</code>
          - returns address to beginning of segment
          <li>
            <code>__intrinsic int __sfe(void *)</code>
          - returns address to end of segment
          <li>
            <code>__intrinsic int __sfs(void *)</code> - returns size of segment</li>
        </ul>
      <li>
        Code for spilling and unspilling high registers in Thumb mode has been 
        corrected.<br>
      [ARMC0001]
      <li>
      A problem that under some circumstances could result in a never-ending compiler 
      internal loop is corrected.
      <li>
        Volatile objects referred by a pointer, are now handled correctly.
      </li>
    </ul>
    <h4><A NAME="his120A">V1.20A 2000-05-28</A></h4>
    <ul>
      <li>
        The following C library functions will under certain circumstances be handled 
        as intrinsic functions and will generate inline code instead of an ordinary 
        library call: <code>memcpy, memset, strcpy, strlen, strncpy, strcat, strcmp, 
          strncmp</code>
      </li>
    </ul>
    <h4><A NAME="his11B">V1.10B 2000-01-14</A></h4>
    <ul>
      <li>
      Minor corrections.
      <li>
        Switch statements in ARM mode are now implemented more efficiently, using jump 
        tables.</li>
    </ul>
    <h4><A NAME="his110A">V1.10A 1999-12-30</A></h4>
    <ul>
      <li>
        First release.
      </li>
    </ul>
    </div>
  </body>
</html>
